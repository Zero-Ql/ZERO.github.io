<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker之nginx的负载均衡</title>
    <url>/2023/09/12/Docker%E4%B9%8Bnginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h4 id="使用docker部署nginx的负载均衡"><a class="header-anchor" href="#使用docker部署nginx的负载均衡">¶</a>使用docker部署nginx的负载均衡</h4>
<ol>
<li>下载 nginx 和 tomcat 镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx ; docker pull tomcat</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/12/pP2Vg10.png" alt="pP2Vg10.png" loading="lazy"></p>
<ol start="2">
<li>新建tomcat网页</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/www1/ROOT ; mkdir -p /root/www2/ROOT</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/12/pP2VhBF.png" alt="pP2VhBF.png" loading="lazy"></p>
<ol start="3">
<li>进入刚创建的 www1/ROOT 目录里</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/www1/ROOT</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用 vim 创建 index.jsp 文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim index.jsp</span><br></pre></td></tr></table></figure>
<p>输入以下内容：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">           &lt;title&gt;Tomcat1&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;	</span><br><span class="line">           &lt;%</span><br><span class="line">                  out.println(<span class="string">&quot;this is Tomcat1&quot;</span>);</span><br><span class="line">           %&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/12/pP2VoN9.png" alt="pP2VoN9.png" loading="lazy"></p>
<p>在 /root/www2/ROOT/ 下同样创建 index.jsp 文件，输入内容同上，将 Tomcat1 改为 Tomcat2 即可</p>
<ol start="5">
<li>运行 tomcat1 和 tomcat2 ，并且将 docker 的 /root/www1 和 /root/www2 与容器的 /usr/local/webapps 目录映射</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name tomcat1 -p 32769:8080 -v /root/www1:/usr/local/tomcat/webapps tomcat:latest ; docker run -itd --name tomcat2 -p 32770:8080 -v /root/www2:/usr/local/tomcat/webapps tomcat:latest</span><br></pre></td></tr></table></figure>
<p>注：上面是一条命令</p>
<p><img src="https://s1.ax1x.com/2023/09/12/pP2Z3uT.png" alt="pP2Z3uT.png" loading="lazy"></p>
<ol start="6">
<li>在浏览器分别输入以下语句：</li>
</ol>
<blockquote>
<p>你的ip:32769</p>
<p>你的ip:32770</p>
<p>示例：</p>
<p><a href="http://8.222.153.91:32769">tomcat1</a></p>
<p><a href="http://8.222.153.91:32770">tomcat2</a></p>
</blockquote>
<ol start="7">
<li>运行nginx</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name nginx -p 25567:80 nginx:latest</span><br></pre></td></tr></table></figure>
<ol start="8">
<li>在 /root 目录下使用 vim 创建 nginx.conf 文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root ; vim nginx.conf</span><br></pre></td></tr></table></figure>
<p>填入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    </span><br><span class="line">    upstream tomcat &#123;</span><br><span class="line">        server 192.168.100.100:32772;   </span><br><span class="line">        server 192.168.100.100:32773;</span><br><span class="line">&#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name 192.168.100.100;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://tomcat;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 server 后面的 ip 改为你的 ip 加端口号，server_name 同理</p>
<p><img src="https://s1.ax1x.com/2023/09/12/pP2eKde.png" alt="pP2eKde.png" loading="lazy"></p>
<ol start="9">
<li>将 nginx.conf 文件 cp 到你的容器里</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp nginx.conf e11dd26a3930:/etc/nginx/nginx.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">记住，容器 <span class="built_in">id</span> 改为自己的 nginx 容器的 <span class="built_in">id</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/12/pP2MeET.png" alt="pP2MeET.png" loading="lazy"></p>
<ol start="10">
<li>重启 nginx 容器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart 你的nginx容器id</span><br></pre></td></tr></table></figure>
<ol start="11">
<li>浏览器访问你服务器的ip，因为我的 80 端口被占用，所以使用 25567 代替</li>
</ol>
<p><img src="https://s1.ax1x.com/2023/09/12/pP2MmUU.png" alt="pP2MmUU.png" loading="lazy"></p>
<p>刷新会在 tomcat1 和 tomcat2 切换</p>
<p>示例：<a href="http://8.222.153.91:25567">tomcat1 or tomcat2</a></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker构建镜像及使用的笔记</title>
    <url>/2023/09/11/Docker%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E5%8F%8A%E4%BD%BF%E7%94%A8%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h4>
<p>本文并不记录详细过程，只是为了记录一下大概构建及使用的经过（还有踩坑记录，重点！！！）</p>
<hr>
<h4 id="开始"><a class="header-anchor" href="#开始">¶</a>开始</h4>
<p>由于一些特殊原因，我需要一个包含 nodejs 的基础镜像来构建一个新的镜像，但是由于各种原因，没能下成，并且我也不知道哪些镜像中含有 nodejs，所以没办法，只能自己构建一个含有 nodejs 的镜像，为了使镜像最小化，我选择了 alpine 发行的 Linux 镜像</p>
<p>直接 docker pull alpine ，没毛病，下好之后准备 run 的，结果发现根本没有 bash 这个命令，查过资料才发现，它还是用的 sh 。。。。</p>
<p>好了，重新 run ，<code>docker run -it alpine /bin/sh</code> .</p>
<p>这下没毛病了，进了终端，然后竟然发现无从下手！！！（毕竟 alpine 跟 centos 不一样），一开始用的 yum ，结果直接 not found ，，查了资料发现，这玩意儿连 yum 都没有。。只能用 apk ，不愧是最小的 Linux .</p>
<p>在用 apk 将 nodejs 下好后，直接构建，然后尼玛又少了 npm ，淦！</p>
<p>同样的方法，用 apk 下好之后，构建！！！不出意外的话又出意外了，构建的时候有一步比较吃 cpu 资源 ，我用服务器构建了两次，</p>
<hr>
<p>TODO</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的使用-壹</title>
    <url>/2023/09/05/Docker%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%A3%B9/</url>
    <content><![CDATA[<h4 id="Docker使用"><a class="header-anchor" href="#Docker使用">¶</a>Docker使用</h4>
<ul>
<li>在docker容器内运行应用程序</li>
</ul>
<blockquote>
<p><code>docker run ubuntu:15.10 /bin/echo &quot;hello world&quot;</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/05/pPsklv9.png" alt="docker使用1" loading="lazy"></p>
<p>参数解析：</p>
<ol>
<li><code>docker</code>:Docker的二进制执行文件</li>
<li><code>run</code>: 与Docker组合运行一个容器</li>
<li><code>ubuntu:15.10</code>:要运行的镜像，本地没有就会从镜像仓库下载</li>
<li><code>/bin/echo &quot;hello world&quot;</code>:在启动的容器里执行<code>echo</code>命令</li>
</ol>
<ul>
<li>与docker容器进行交互</li>
</ul>
<blockquote>
<p><code>docker run -t -i centos:centos7 /bin/bash</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/05/pPskQgJ.png" alt="docker使用2" loading="lazy"></p>
<p>参数解析：</p>
<ol>
<li><code>-t</code>:在新的容器里指定一个终端</li>
<li><code>-i</code>: 允许与指定的终端进行交互</li>
</ol>
<p>注意：可以用<code>exit</code>退出伪终端</p>
<ul>
<li>通过ps查看正在运行的容器</li>
</ul>
<blockquote>
<p><code>docker ps</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/05/pPskM34.png" alt="docker的使用3" loading="lazy"></p>
<p>参数解析：</p>
<ol>
<li>
<p><code>CONTAINER ID</code>: 容器ID</p>
</li>
<li>
<p><code>IMAGE</code>: 使用的镜像</p>
</li>
<li>
<p><code>COMMAND</code>: 启动镜像时运行的命令</p>
</li>
<li>
<p><code>CREATED</code>: 容器的创建时间</p>
</li>
<li>
<p><code>STATUS</code>: 容器的状态 （容器的七种状态：</p>
<p>1.<code>created</code> 已创建</p>
<p>2.<code>restaring</code> 重启中</p>
<p>3.<code>running</code>或<code>Up</code> 运行中</p>
<p>4.<code>removing </code>迁移中</p>
<p>5.<code>paused </code>暂停</p>
<p>6.<code>exited </code>停止</p>
<p>7.<code>dead </code>死亡）</p>
</li>
<li>
<p><code>PORTS</code>: 容器的端口信息和使用的连接类型（<code>TCP/UDP</code>）</p>
</li>
<li>
<p><code>NAMES</code>: 自动分配的容器名称</p>
</li>
</ol>
<h5 id="常用命令"><a class="header-anchor" href="#常用命令">¶</a>常用命令</h5>
<ol>
<li><code>docker images</code>        	列出本地主机上的镜像</li>
<li><code>docker search centos[:7] </code>      	 搜索镜像</li>
<li><code>docker pull centos[:centos7] </code>      	 下载镜像</li>
<li><code>docker tag centos:centos7 mycentos:centos7 </code>       	为镜像添加标签，其中分号前为镜像类型，分号后为镜像版本</li>
<li><code>docker history centos:centos7 </code>       	查看镜像的构建历史信息</li>
<li><code>docker rmi centos:centos7</code>        	删除镜像（可以使用<code>-f</code>强制删除，在删除使用tag标签标记的镜像时可以不用加<code>-f</code>参数）</li>
<li><code>docker image prune [-a] [-f]</code>        清理镜像，加<code>-a</code>参数即删除所有无用的镜像，不仅仅是临时镜像 <code>-f</code>参数即可强制删除镜像而不提示</li>
<li><code>docker image save centos:centos7 &gt; ./my-centos7.tar.gz </code>       导出镜像到当前目录，格式为一个压缩包（可以自行选择导出的位置）</li>
<li><code>docker image load [-i] [-q] ./my-centos7.tar.gz</code>        将centos7的镜像压缩包导入，<code>-i</code>参数是指定导入的文件，<code>-q</code>参数是精简输出信息</li>
<li><code>docker image inspect [-f] &#123; &#123;&quot;.Os&quot;&#125; &#125; centos:centos7</code>        查看镜像信息，可以使用<code>-f</code>参数获取指定信息</li>
<li><code>docker restart $(docker ps -a -q)</code> 重启所有 docker 容器</li>
</ol>
<p>注意：[ ] 里的为可选内容，选择具体版本</p>
<hr>
<p>TODO</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的使用-叁</title>
    <url>/2023/09/08/Docker%E7%9A%84%E4%BD%BF%E7%94%A8-%E5%8F%81/</url>
    <content><![CDATA[<h4 id="Dockerfile的使用"><a class="header-anchor" href="#Dockerfile的使用">¶</a>Dockerfile的使用</h4>
<p>使用Dockerfile部署扫雷web程序</p>
<ol>
<li>
<p>先将必要的文件上传至服务器，然后在当前目录创建init.sh和dockerfile文件</p>
<p>友情提示：可以使用 scp 上传</p>
<ul>
<li>scp 不会用那就用下面的这条命令，我把资源都打包到我服务器上了，可以直接下：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://zero-li.fun/资源/source.tar ; tar -xf source.tar ; mv -f source/* ./ ; rm -rf sour*</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/08/pP6Celd.png" alt="pP6Celd.png" loading="lazy"></p>
</li>
<li>
<p>通过 vim 向 dockerfile  <a href="http://xn--init-990g.sh">及init.sh</a> 写入以下内容：</p>
</li>
</ol>
<blockquote>
<p>请不要照抄我的配置，每句后面都有注释，稍微动一下脑子就行了，要不然寄</p>
</blockquote>
<p>使用dockerfile之前，你首先要确保你的当前目录下有以下几个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Centos-7.repo</p>
<p>epel-7.repo</p>
<p>saolei.zip</p>
<p>dockerfile</p>
<p><a href="http://init.sh">init.sh</a></p>
</blockquote>
<p>你还要确保你的本地有 centos:centos7 这个镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/10/pPcdAF1.png" alt="pPcdAF1.png" loading="lazy"></p>
<p>没有怎么办？凉拌！！！</p>
<p>用下面这条命令下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos:centos7 </span><br></pre></td></tr></table></figure>
<p>要是还报错，那你就自己百度去吧，问题奇奇怪怪的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos:centos7    # 这是你要使用的基础镜像，记住改为自己的基础镜像(如果你使用了上面的 pull 下载了镜像，就不需要改)</span><br><span class="line">  </span><br><span class="line">ADD Centos-7.repo /etc/yum.repos.d/    # 这条命令的意思是添加Centos7.repo文件到容器的/etc/yum.repos.d下</span><br><span class="line"></span><br><span class="line">ADD epel-7.repo /etc/yum.repos.d/    # 同上</span><br><span class="line"></span><br><span class="line">RUN yum -y install tomcat unzip curl    # 运行 yum 命令安装 tomcat 、 unzip 、 curl ，其中 -y 表示安装过程中的选择全部为 yes</span><br><span class="line"></span><br><span class="line">WORKDIR /var/lib/tomcat/webapps/    # 指定工作目录</span><br><span class="line"></span><br><span class="line">RUN curl -O https://zero-li.fun/资源/saolei.zip    # 从指定站点下载 saolei.zip 资源</span><br><span class="line"></span><br><span class="line">RUN unzip saolei.zip    # 解压 saolei.zip 文件</span><br><span class="line"></span><br><span class="line">RUN mv saolei ROOT     # 将 saolei 移动至 ROOT 文件或目录</span><br><span class="line"></span><br><span class="line">ADD init.sh /init.sh    # 添加 init.sh 至 /init.sh</span><br><span class="line"></span><br><span class="line">EXPOSE 8080    # 声明 8080 端口 ，此时并没有开放此端口</span><br><span class="line"></span><br><span class="line">CMD [&quot;/bin/bash&quot;,&quot;/init.sh&quot;]    # 在容器启动时运行 /init.sh 脚本</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">  </span><br><span class="line">/usr/libexec/tomcat/server start    # 在指定目录启动 tomcat server 服务器                </span><br></pre></td></tr></table></figure>
<ol start="3">
<li>直接构建镜像</li>
</ol>
<blockquote>
<p>docker build -t saolei:v1 .</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/08/pP6PyUf.png" alt="pP6PyUf.png" loading="lazy"></p>
<ol start="4">
<li>运行容器</li>
</ol>
<blockquote>
<p>docker run -itd -P saolei:v1</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/08/pP6PWvj.png" alt="pP6PWvj.png" loading="lazy"></p>
<ol start="5">
<li>在浏览器通过 ”你的IP“:开放的随机端口/saolei.jsp 访问</li>
</ol>
<p><img src="https://s1.ax1x.com/2023/09/08/pP6PjM9.png" alt="pP6PjM9.png" loading="lazy"></p>
<hr>
<p>示例: <a href="http://8.222.153.91:32770/saolei.jsp?level=8&amp;leiNum=8&amp;size=8">扫雷</a></p>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署</title>
    <url>/2023/09/04/Docker%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="Docker部署"><a class="header-anchor" href="#Docker部署">¶</a>Docker部署</h3>
<blockquote>
<p>前言：部署docker要先确保yum源保持最新</p>
</blockquote>
<hr>
<p>1.先安装运行docker所必要的工具包</p>
<blockquote>
<p><code>yum install -y yum-utils device-mapper-persistent-data lvm2</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVkQJ.png" alt="docker1" loading="lazy"></p>
<p>2.添加docker源</p>
<blockquote>
<p><code>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrViz4.png" alt="pPrViz4.png" loading="lazy"></p>
<p>3.修改docker源为阿里源</p>
<blockquote>
<p><code>sed -i 's+download.docker.com+mirrors.aliyun.com/docker-ce+' /etc/yum.repos.d/docker-ce.repo</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVPWF.png" alt="pPrVPWF.png" loading="lazy"></p>
<p>4.更新docker源并安装docker</p>
<blockquote>
<p>更新源 <code>yum makecache fast</code></p>
<p>安装 <code>yum  -y install docker-ce</code></p>
<p>注意：在Centos8中本命令不适用，将fast去掉即可</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrV9iT.png" alt="pPrV9iT.png" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVSoV.png" alt="pPrVSoV.png" loading="lazy"></p>
<p>5.重启docker服务并设置下次启动生效</p>
<blockquote>
<p>重新启动 <code>systemctl  restart  docker</code></p>
<p>设置下次启动生效 <code>systemctl  enable  docker</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVCJU.png" alt="pPrVCJU.png" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVAy9.png" alt="pPrVAy9.png" loading="lazy"></p>
<p>6.配置镜像加速器</p>
<blockquote>
<p>用vim创建<code>daemon.json</code>文件</p>
<p><code>vim /etc/docker/daemon.json</code></p>
<p>写入以下内容:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://14lrk6zd.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVELR.png" alt="pPrVELR.png" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVZe1.png" alt="pPrVZe1.png" loading="lazy"></p>
<p>7.重新加载并重启docker</p>
<blockquote>
<p>重新加载 <code>systemctl  daemon-reload</code></p>
<p>重启 <code>systemctl restart docker</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVedx.png" alt="pPrVedx.png" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/09/04/pPrVmo6.png" alt="pPrVmo6.png" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>Git同时部署多个仓库</title>
    <url>/2023/10/26/Git%E5%90%8C%E6%97%B6%E9%83%A8%E7%BD%B2%E5%A4%9A%E4%B8%AA%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h4 id="私有仓库的配置"><a class="header-anchor" href="#私有仓库的配置">¶</a>私有仓库的配置</h4>
<p>刚需：先在服务器端创建 git 用户，并且配置用户密码</p>
<p>可以使用下面的命令创建和修改</p>
<blockquote>
<p>useradd git</p>
<p>passwd git</p>
<p>#注：密码要输入两次确认</p>
</blockquote>
<h5 id="服务器端配置："><a class="header-anchor" href="#服务器端配置：">¶</a>服务器端配置：</h5>
<blockquote>
<p>su git 	#切换到 git 用户</p>
<p>cd 	#进入用户家目录</p>
<p>mkdir .ssh ; cd .ssh  	#创建 .ssh 配置目录并进入</p>
<p>touch authorized_keys 	#创建 authorized_keys 来存放公钥</p>
<p>chmod 700 /home/git/.ssh/ ; chmod 600 /home/git/.ssh/authorized_keys 	#修改 .ssh 及 authorized_keys 的权限</p>
<p>vim /etc/ssh/sshd_config</p>
<p>#在此文件中查找以下字段是否存在或取消注释</p>
<p>#1. RSAAuthentication yes</p>
<p>#2. PubkeyAuthentication yes</p>
<p>#3. AuthorizedkeysFile .ssh/authorized_keys</p>
</blockquote>
<h5 id="客户端生成公钥："><a class="header-anchor" href="#客户端生成公钥：">¶</a>客户端生成公钥：</h5>
<blockquote>
<p>ssh-keygen -t rsa -f “id_rsa_git” 	#使用 -f 来区分生成的公钥文件</p>
</blockquote>
<h4 id="配置-Github-和-Gitee-仓库"><a class="header-anchor" href="#配置-Github-和-Gitee-仓库">¶</a>配置 Github 和 Gitee 仓库</h4>
<blockquote>
<p>ssh-keygen -t rsa -C “<a href="mailto:2704984649@qq.com">2704984649@qq.com</a>” -f “id_rsa_gitee”</p>
<p>ssh-keygen -t rsa -C “<a href="mailto:2704984649@qq.com">2704984649@qq.com</a>” -f “id_rsa_github”</p>
</blockquote>
<p>注：生成公钥请在 C:\Users\ 用户名 \ .ssh\ 这个目录下的终端里进行，文件名为 .pub 后缀的文件为公钥文件</p>
<p>然后将不同仓库的公钥里的值分别添加到不同的仓库里即可</p>
<p>私有仓库则将值添加到 git 用户的 .ssh/authorized_keys 里</p>
<p>注：可以使用 echo “值” &gt;&gt; authorized_keys 将值追加到文件里，这样可以防止覆盖以前配置的 ssh 公钥，防止其他用户无法使用免密登录</p>
<p>然后配置本地主机的 C:\Users\ 用户名 \ .ssh\ 这个目录下的 config.config 文件来解决 ssh 冲突问题 ，没有就创建一个，然后填入以下内容</p>
<blockquote>
<p>#git 用户</p>
<p>Host githost 	#别名<br>
HostName 8.222.153.91 	#主机地址<br>
Post 5213 	#端口<br>
User git 	#用户名<br>
IdentityFile ~/.ssh/id_rsa.pub 	#公钥位置，一般位于 C:\\Users\qingtian\.ssh\ 下</p>
<p>#root 用户</p>
<p>Host roothost<br>
HostName 8.222.153.91<br>
Post 5213<br>
User root<br>
IdentityFile ~/.ssh/id_rsa.pub</p>
<p>#git 登录 github</p>
<p>Host <a href="http://github.com">github.com</a><br>
HostName <a href="http://github.com">github.com</a><br>
User git<br>
IdentityFile ~/.ssh/id_rsa_github.pub</p>
<p>#git 登录 gitee</p>
<p>Host <a href="http://gitee.com">gitee.com</a><br>
HostName <a href="http://gitee.com">gitee.com</a><br>
User git<br>
IdentityFile ~/.ssh/id_rsa_gitee.pub</p>
</blockquote>
<p>也可以在使用 ssh 的时候在后面使用 -p 参数指定端口</p>
<blockquote>
<p>ssh <a href="mailto:git@8.222.153.91">git@8.222.153.91</a> -p 5213</p>
</blockquote>
<p>然后可以使用下面的命令测试登录：</p>
<blockquote>
<p>ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a></p>
<p>ssh -T <a href="mailto:git@github.com">git@github.com</a></p>
</blockquote>
<h4 id="查看-git-的-push-模式"><a class="header-anchor" href="#查看-git-的-push-模式">¶</a>查看 git 的 push 模式</h4>
<blockquote>
<p>git remote -v</p>
<p>git remote set-url origin 你的仓库地址 	#修改不同的模式用不同的仓库地址</p>
</blockquote>
<h4 id="坑"><a class="header-anchor" href="#坑">¶</a>坑</h4>
<ol>
<li>如果使用 ssh -T <a href="mailto:git@gitee.com">git@gitee.com</a> 或者 ssh -T <a href="mailto:git@github.com">git@github.com</a> 来测试登录显示如下报错：</li>
</ol>
<blockquote>
<p><a href="mailto:git@gitee.com">git@gitee.com</a>: Permission denied (publickey).</p>
</blockquote>
<h5 id="解决"><a class="header-anchor" href="#解决">¶</a>解决</h5>
<p>如果检查公钥配置没有问题，使用下面的命令将本机的 git 仓库与相对应的 SSH Key 关联上即可</p>
<blockquote>
<p>ssh-agent bash 	#打开身份代理验证连接</p>
<p>ssh-add ~/.ssh/id_rsa_gitee 	#你的 gitee 私钥文件位置</p>
<p>ssh-add ~/.ssh/id_rsa_github 	#你的 github 私钥文件位置</p>
</blockquote>
<ol start="2">
<li>在关闭 git bash 窗口后要重新添加关联，暂无解决办法</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-lambda的方法引用</title>
    <url>/2023/07/11/Java-lambda%E7%9A%84%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h5 id="方法引用"><a class="header-anchor" href="#方法引用">¶</a>方法引用</h5>
<p>方法引用有四种引用方法</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">语法</th>
<th style="text-align:center">对应的lambda表达式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">对象引用非静态方法</td>
<td style="text-align:center">对象名 : : 实例方法名</td>
<td style="text-align:center">（ i ) -&gt; 对象名.实例方法名( i )</td>
</tr>
<tr>
<td style="text-align:center">类引用静态方法</td>
<td style="text-align:center">类名 : : 静态方法名 引用</td>
<td style="text-align:center">( i ) -&gt; 类名.静态方法名( i )</td>
</tr>
<tr>
<td style="text-align:center">类引用非静态方法</td>
<td style="text-align:center">类名 : : 实例方法名 引用</td>
<td style="text-align:center">( i ) -&gt; 类名.实例方法名( i )</td>
</tr>
<tr>
<td style="text-align:center">类引用构造方法</td>
<td style="text-align:center">类名 : : new	//构造引用</td>
<td style="text-align:center">( i ) -&gt; new 类名( i )</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>千万注意，要引用的方法的形参和返回值一定要跟接口的一样，要不然找不到这个方法的</strong></li>
</ul>
<p><em><strong>[ code = java ]</strong></em></p>
<blockquote>
<p><code>对象名::实例方法名</code>引用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义一个接口,可以接受泛型,接口必须是函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Simple</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//形参为Optional，Optional是一个可以存储null值的容器对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testM</span><span class="params">(Optional&lt;T&gt; x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">//要引用的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(Optional&lt;T&gt; x)</span>&#123;</span><br><span class="line">        System.out.println(x.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//通过 对象名：：方法名 引用</span></span><br><span class="line">        <span class="comment">//方法接收任意类型的对象，new一个本类对象，引用本类的m方法</span></span><br><span class="line">        Simple1&lt;Object&gt; simple = <span class="keyword">new</span> <span class="title class_">Main</span>()::m;</span><br><span class="line">        <span class="comment">//of方法将非null值转换为Optional对象</span></span><br><span class="line">        simple.testM(Optional.of(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对应的lambda表达式，结果一样</span></span><br><span class="line">        Simple1&lt;Object&gt; simple1 = (i) -&gt; <span class="keyword">new</span> <span class="title class_">Main</span>().m(i);</span><br><span class="line">        simple1.testM(Optional.of(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>[ code = java ]</strong></em></p>
<blockquote>
<p><code>类名::静态方法名</code>引用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//还是先定义一个接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Simple</span>&#123;</span><br><span class="line">    Integer <span class="title function_">test</span><span class="params">(String s)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后定义一个实现类，这个类里面就是要引用的静态方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main2</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">m</span><span class="params">(String t)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//静态方法可以直接通过类名引用</span></span><br><span class="line">        <span class="type">Simple</span> <span class="variable">simple</span> <span class="operator">=</span> Main2::m;</span><br><span class="line">        System.out.println(simple.test(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对应的lambda表达式</span></span><br><span class="line">        <span class="type">Simple</span> <span class="variable">simple22</span> <span class="operator">=</span> (i) -&gt; Main2.m(i);</span><br><span class="line">        System.out.println(simple22.test(<span class="string">&quot;hello world!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>[ code = java ]</strong></em></p>
<blockquote>
<p><code>类名::实例方法名</code>引用</p>
<p>只有接口中有两个及以上形参，且第一个参数是调用者，其他参数是被调用者才能使用此类型引用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义一个接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Simple</span>&#123;</span><br><span class="line">    String <span class="title function_">test</span><span class="params">(Main2 M,String s,String j)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">m</span><span class="params">(String i,String j)</span>&#123;</span><br><span class="line">        <span class="comment">//链式调用将字符串拼接</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.i.concat(i).concat(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Simple</span> <span class="variable">simple</span> <span class="operator">=</span> Main2::m;</span><br><span class="line">        System.out.println(simple.test(<span class="keyword">new</span> <span class="title class_">Main2</span>(),<span class="string">&quot;world&quot;</span>,<span class="string">&quot;!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//花里胡哨的</span></span><br><span class="line"><span class="comment">//对应的lambda方式没整出来。。。</span></span><br></pre></td></tr></table></figure>
<p><em><strong>[ code = java ]</strong></em></p>
<blockquote>
<p><code>类名::new</code>引用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将上面的代码小改一手</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Simple4</span>&#123;</span><br><span class="line">    <span class="comment">//返回值为实现接口的类，参数就是实现类的构造方法参数</span></span><br><span class="line">    Main2 <span class="title function_">test</span><span class="params">(String i)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String i;</span><br><span class="line">    Main2(String i)&#123;</span><br><span class="line">        <span class="built_in">this</span>.i=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.i.concat(<span class="string">&quot;world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Simple</span> <span class="variable">simple</span> <span class="operator">=</span> Main2::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">//simple.test返回的其实就是一个实现类对象</span></span><br><span class="line">        System.out.println(simple.test(<span class="string">&quot;hello &quot;</span>).getI());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的使用</title>
    <url>/2023/10/26/Git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="Git概念"><a class="header-anchor" href="#Git概念">¶</a>Git概念</h4>
<p>git 分为工作区、暂存区和版本库</p>
<p>工作区：就是你能直接看见的文件</p>
<p>暂存区：暂存区位于 .git/index 文件中，暂存区中存储的都是索引</p>
<p>版本库：整个 .git 文件夹即为版本库</p>
<p>在版本库中还存有 master 分支所代表的目录树</p>
<p>一般用 HEAD 来代指当前分支，HEAD 是一个指向 master 分支的指针</p>
<h5 id="推送流程"><a class="header-anchor" href="#推送流程">¶</a>推送流程</h5>
<p>git add . # 将当前目录下的所有内容添加到暂存区，此时并不会 commit 到版本库</p>
<p>git commit -m “update” # 将暂存区的文件提交到版本库，后面的字符串为提交说明</p>
<p>git push git仓库位置 # 此时会将版本库中的文件提交到远程 git 仓库</p>
<blockquote>
<p>git add  》 git commit  》git push</p>
</blockquote>
<p>图解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">	工作区-&gt;&gt;暂存区: add # 添加</span><br><span class="line">	暂存区-&gt;&gt;版本库: commit # 提交</span><br><span class="line">	版本库-&gt;&gt;远程仓库: push # 推送</span><br><span class="line">	远程仓库-&gt;&gt;版本库: clone # 克隆</span><br><span class="line">	远程仓库-&gt;&gt;工作区: pull # 拉取</span><br><span class="line">	版本库-&gt;&gt;工作区: checkout # 分支切换</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数解析：</p>
<p>add ：添加文件到暂存区</p>
<p>commit ：提交文件到版本库/本地仓库</p>
<p>push：推送文件到远程仓库</p>
<p>clone：将一个项目克隆到本地仓库</p>
<p>pull：拉取一个仓库到本地</p>
<p>checkout：切换分支</p>
</blockquote>
<h4 id="Git-的基本操作"><a class="header-anchor" href="#Git-的基本操作">¶</a>Git 的基本操作</h4>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">git init</td>
<td style="text-align:center"><code>[file]</code></td>
<td style="text-align:center">初始化仓库</td>
</tr>
<tr>
<td style="text-align:center"><code>git status</code></td>
<td style="text-align:center"><code>[-s]</code></td>
<td style="text-align:center">查看仓库当前的状态，显示有变更的文件，加 -s 参数使其简短输出</td>
</tr>
<tr>
<td style="text-align:center">git diff</td>
<td style="text-align:center"><code>[--cached]</code> <code>[HEAD]</code></td>
<td style="text-align:center">比较文件的不同，即暂存区和工作区的差异，可以使用 --cachaed 显示已缓存的改动，使用 HEAD 显示所有已缓存和未缓存的改动</td>
</tr>
<tr>
<td style="text-align:center"><code>git reset</code></td>
<td style="text-align:center"><code>[HEAD~1]</code> <code>[file]</code></td>
<td style="text-align:center">回退版本，回退到添加或提交之前，或使用 --soft HEAD~3 参数指定回退到上上上个版本</td>
</tr>
<tr>
<td style="text-align:center">git rm</td>
<td style="text-align:center"></td>
<td style="text-align:center">将文件从暂存区和工作区删除</td>
</tr>
<tr>
<td style="text-align:center"><code>git mv</code></td>
<td style="text-align:center"><code>[-f] [file] [newfile]</code></td>
<td style="text-align:center">移动或重命名工作区文件，添加 -f 参数来重命名文件</td>
</tr>
<tr>
<td style="text-align:center">git switch</td>
<td style="text-align:center"><code>&lt;branch-name&gt;</code> <code>[-c] &lt;new-branch-name&gt;</code> <code>tags/&lt;tag-name&gt;</code></td>
<td style="text-align:center">更清晰的切换分支，切换到指定分支。使用 -c 创建分支并切换到新创建的分支。使用 tags/ 切换到标签所指向的提交状态</td>
</tr>
<tr>
<td style="text-align:center">git restore</td>
<td style="text-align:center"><code>&lt;file&gt;</code> <code>--staged &lt;file&gt;</code> <code>--source=&lt;commit&gt; &lt;file&gt;</code></td>
<td style="text-align:center">恢复或撤销文件的更改。指定文件名将其恢复至最新的提交状态，丢弃所有未提交的更改。使用 --staged 将文件还原到添加到暂存区之前。使用 --source 将文件还原到指定的历史版本</td>
</tr>
<tr>
<td style="text-align:center">git branch</td>
<td style="text-align:center"><code>[new-branch-name]</code></td>
<td style="text-align:center">查看可用分支和标签。加参数新建分支</td>
</tr>
</tbody>
</table>
<h4 id="Git-分支管理"><a class="header-anchor" href="#Git-分支管理">¶</a>Git 分支管理</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	A(master)--&gt;B(master);</span><br><span class="line">	B--&gt;D(master);</span><br><span class="line">	D(master)--&gt;E(master);</span><br><span class="line">	E(master)--&gt;F(master);</span><br><span class="line">	</span><br><span class="line">	B(master)--&gt;B1(b1);</span><br><span class="line">	B1(b1)--&gt;B2(b2);</span><br><span class="line">	</span><br><span class="line">	E(master)--&gt;E1(e1);</span><br><span class="line">	E1(e1)--&gt;E2(e2);</span><br><span class="line">	HEAD--&gt;E2(head);</span><br><span class="line">	</span><br><span class="line">	图解</span><br></pre></td></tr></table></figure>
<h5 id="合并分支-删除分支"><a class="header-anchor" href="#合并分支-删除分支">¶</a>合并分支 &amp; 删除分支</h5>
<p>如上图所示，创建一个分支之后就是从那个提交历史节点 clone 一个新的节点，在此节点上所做的任何更改都不会影响到主分支。主分支所做的改动同样也不会影响到别的分支节点，但是要注意，可以使用以下命令来将指定的分支合并到主分支</p>
<blockquote>
<p><code>git merge &lt;branch-name&gt;</code></p>
</blockquote>
<p>在分支被合并之后就可以删除此分支</p>
<blockquote>
<p><code>git branch -d &lt;branch-name&gt;</code></p>
</blockquote>
<h5 id="合并冲突"><a class="header-anchor" href="#合并冲突">¶</a>合并冲突</h5>
<p>当你在主分支更改了一个文件并且将更改提交到了版本库，又在另一个分支上同样更改了这个文件并且也提交到了版本库时，这个时候假设你想要将这个分支合并到主分支上，此时会出现合并冲突问题，这需要我们去手动解决</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Decimal-conversion</span><br><span class="line">进制转换</span><br><span class="line">- 按照提示输入即可</span><br><span class="line"></span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">hello world</span><br><span class="line">=======</span><br><span class="line">你好世界</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; master</span><br></pre></td></tr></table></figure>
<p>在上面的文件 <a href="http://README.md">README.md</a> 中，我们在主分支中添加了 hello world 内容。在 master 分支中添加了 你好世界 内容。</p>
</blockquote>
<p>解决冲突只需要将 <a href="http://README.md">README.md</a> 中的标记删除然后重新添加和提交即可</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Decimal-conversion</span><br><span class="line">进制转换</span><br><span class="line">- 按照提示输入即可</span><br><span class="line"></span><br><span class="line">hello world</span><br><span class="line">你好世界</span><br></pre></td></tr></table></figure>
<p>修改之后用 git add 添加和 git commit 提交</p>
</blockquote>
<h4 id="查看-Git-的提交历史"><a class="header-anchor" href="#查看-Git-的提交历史">¶</a>查看 Git 的提交历史</h4>
<h5 id="Git-log"><a class="header-anchor" href="#Git-log">¶</a>Git log</h5>
<blockquote>
<p><code>git log</code></p>
<p>使用此命令会显示从最新到最旧的所有提交信息，包括提交的哈希值、作者、提交日期、提交说明</p>
</blockquote>
<p>命令语法：</p>
<p>​	<code>git log [选项] [分支名/提交哈希]</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-p</code></td>
<td style="text-align:center">显示提交的具体更改</td>
</tr>
<tr>
<td style="text-align:center"><code>--oneline</code></td>
<td style="text-align:center">以简洁的一行格式显示提交信息</td>
</tr>
<tr>
<td style="text-align:center"><code>--graph</code></td>
<td style="text-align:center">以图形化的方式显示分支和合并历史</td>
</tr>
<tr>
<td style="text-align:center"><code>--decorate</code></td>
<td style="text-align:center">显示分支和标签指向的提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--author=&lt;作者&gt;</code></td>
<td style="text-align:center">只显示指定的作者的提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--since=&lt;时间&gt;</code></td>
<td style="text-align:center">只显示特定时间之后的提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--until=&lt;时间&gt;</code></td>
<td style="text-align:center">只显示特定时间之前的提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--grep=&lt;模式&gt;</code></td>
<td style="text-align:center">只显示包含特定模式的提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--no-merges</code></td>
<td style="text-align:center">不显示合并提交</td>
</tr>
<tr>
<td style="text-align:center"><code>--stat</code></td>
<td style="text-align:center">显示简略统计信息，包括修改的文件和行数</td>
</tr>
<tr>
<td style="text-align:center"><code>--abbrev-commit</code></td>
<td style="text-align:center">使用短提交哈希值</td>
</tr>
<tr>
<td style="text-align:center"><code>--pretty=&lt;格式&gt;</code></td>
<td style="text-align:center">使用自定义的提交信息的显示格式</td>
</tr>
<tr>
<td style="text-align:center"><code>--reverse</code></td>
<td style="text-align:center">逆向显示所有日志</td>
</tr>
</tbody>
</table>
<blockquote>
<p>使用 <code>git log</code> 命令会输出以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 0c98d56e9822f23406758d2339833ffec7af0c1a (HEAD -&gt; main)</span><br><span class="line">Merge: 434acee e6e3e72</span><br><span class="line">Author: 清天 &lt;2704984649@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 26 11:11:19 2023 +0800</span><br><span class="line"></span><br><span class="line">	test3</span><br><span class="line"></span><br><span class="line">commit e6e3e72d10cf8b1218e0118beac857af06ff57cd (master)</span><br><span class="line">Author: 清天 &lt;2704984649@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 26 10:59:53 2023 +0800</span><br><span class="line"></span><br><span class="line">	test2</span><br><span class="line"></span><br><span class="line">commit 434aceeb3a6fbac0ec94fdbedb15d74455528f2f</span><br><span class="line">Author: 清天 &lt;2704984649@qq.com&gt;</span><br><span class="line">Date:   Thu Oct 26 10:58:50 2023 +0800</span><br><span class="line"></span><br><span class="line">	 test</span><br><span class="line"></span><br><span class="line">commit 33e6c64449e0e094e19d7aea162bfddc23a10832</span><br><span class="line">Author: 清天 &lt;2704984649@qq.com&gt;</span><br><span class="line">Date:   Wed Oct 25 10:29:18 2023 +0800</span><br><span class="line"></span><br><span class="line">	README.md</span><br></pre></td></tr></table></figure>
<p>使用 <code>git log --oneline --graph</code> 以图形化的方式显示简洁的一行提交信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --graph</span><br><span class="line">*   0c98d56 (HEAD -&gt; main) test3</span><br><span class="line">|\</span><br><span class="line">| * e6e3e72 (master) test2</span><br><span class="line">* | 434acee test</span><br><span class="line">|/</span><br><span class="line">* 33e6c64 README.md</span><br><span class="line">* 4fa856d README.md</span><br><span class="line">* aaba7d0 (origin/main, origin/HEAD) Create README.md</span><br><span class="line">* 76836c5 Delete .gitignore</span><br><span class="line">* 4e6c20b Add files via upload</span><br><span class="line">* cb5ab48 Initial commit</span><br></pre></td></tr></table></figure>
<p>此时可以清晰的看见何时工作分叉，又何时合并分支</p>
</blockquote>
<p>可以使用 <code>git log --help</code> 查看帮助信息</p>
<h5 id="Git-blame"><a class="header-anchor" href="#Git-blame">¶</a>Git blame</h5>
<blockquote>
<p><code>git blame</code></p>
<p>使用此命令可以查看指定文件的每一行代码是由谁在什么时候引入或修改的</p>
</blockquote>
<p>命令语法：</p>
<p>​	<code>git blame [选项] &lt;文件路径&gt;</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-L &lt;起始行号&gt;,&lt;结束行号&gt;</code></td>
<td style="text-align:center">只显示指定行号范围内的代码注释</td>
</tr>
<tr>
<td style="text-align:center"><code>-C</code></td>
<td style="text-align:center">对于重命名或拷贝的代码行，也进行代码行溯源</td>
</tr>
<tr>
<td style="text-align:center"><code>-M</code></td>
<td style="text-align:center">对于移动的代码行，也进行代码行溯源</td>
</tr>
<tr>
<td style="text-align:center"><code>-C -C</code> or <code>-M -M</code></td>
<td style="text-align:center">对于较多改动的代码行，进行更进一步的溯源</td>
</tr>
<tr>
<td style="text-align:center"><code>--show-stats</code></td>
<td style="text-align:center">显示包含每个作者的行数统计信息</td>
</tr>
</tbody>
</table>
<p>更多用法可以使用 <code>git blame --help</code> 查看帮助文档</p>
<h4 id="Git-标签"><a class="header-anchor" href="#Git-标签">¶</a>Git 标签</h4>
<p><code>git tag -a &lt;标签名&gt;</code></p>
<p>在发布版本的时候，可以使用 tag 来给本次提交打上标签。使用 -a 参数来创建一个带注解的标签，加上这个参数它会记录此标签是何时打的，谁打的，以及让你添加一个标签的注解</p>
<p><code>git tag -a &lt;标签名&gt; &lt;提交哈希&gt;</code></p>
<p>你可以使用上面的命令给以前的提交追加 tag 标签。我给 <code>e6e3e72</code> 这个提交追加了 <code>v0.9</code> 的标签</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -a v0.9 e6e3e72</span><br><span class="line">*   0c98d56 (HEAD -&gt; main, tag: v1.0) test3</span><br><span class="line">|\</span><br><span class="line">| * e6e3e72 (tag: v0.9, master) test2 	# 此处显示了追加的标签</span><br><span class="line">* | 434acee test</span><br><span class="line">|/</span><br><span class="line">* 33e6c64 README.md</span><br><span class="line">* 4fa856d README.md</span><br><span class="line">* aaba7d0 (origin/main, origin/HEAD) Create README.md</span><br><span class="line">* 76836c5 Delete .gitignore</span><br><span class="line">* 4e6c20b Add files via upload</span><br><span class="line">* cb5ab48 Initial commit</span><br></pre></td></tr></table></figure>
<p><code>git log --decorate</code></p>
<p>使用此命令来查看我们打的标签</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log --oneline --decorate --graph</span><br><span class="line">*   0c98d56 (HEAD -&gt; main, tag: v1.0) test3</span><br><span class="line">|\</span><br><span class="line">| * e6e3e72 (tag: v0.9, master) test2</span><br><span class="line">* | 434acee test</span><br><span class="line">|/</span><br><span class="line">* 33e6c64 README.md</span><br><span class="line">* 4fa856d README.md</span><br><span class="line">* aaba7d0 (origin/main, origin/HEAD) Create README.md</span><br><span class="line">* 76836c5 Delete .gitignore</span><br><span class="line">* 4e6c20b Add files via upload</span><br><span class="line">* cb5ab48 Initial commit</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>git tag</code> 来查看所有的标签</p>
<p>指定标签信息的命令：</p>
<p><code>git tag -a &lt;标签名&gt; -m &lt;标签信息&gt;</code></p>
<p>PGP签名标签命令：<br>
<code>git tag -s &lt;标签名&gt; -m &lt;标签信息&gt;</code></p>
<p><code>gti tag -d v0.9</code><br>
使用上面的命令删除指定的标签</p>
<h4 id="Git-远程仓库操作"><a class="header-anchor" href="#Git-远程仓库操作">¶</a>Git 远程仓库操作</h4>
<h5 id="添加远程仓库"><a class="header-anchor" href="#添加远程仓库">¶</a>添加远程仓库</h5>
<p><code>git remote add &lt;仓库别名&gt; &lt;仓库的 ssh url 地址&gt;</code></p>
<ul>
<li>使用以上命令可以添加一个远程仓库并设置别名，别名在推送时会用的上</li>
</ul>
<h5 id="推送"><a class="header-anchor" href="#推送">¶</a>推送</h5>
<p>推送代码到仓库里有两种方法：</p>
<ol>
<li>
<p>然后使用 <code>git push -u &lt;仓库别名&gt; master</code>来将本地的 master 分支推送到 origin 的 master 分支上</p>
</li>
<li>
<p>也可以使用 <code>git push &lt;仓库地址&gt;</code> 来推送你的当前分支</p>
</li>
</ol>
<ul>
<li>
<p>这两种方法的区别是第一种方法来推送是将本地的 master 分支推送到 origin 主机的 master 分支，并且指定 你所设置的仓库别名所代表的主机为默认主机，这样在以后推送时就可以不加任何参数的使用 <code>git push</code></p>
</li>
<li>
<p>第二种方法只是单纯的将本地的当前分支上传到指定的远程仓库地址，并不会指定默认主机，也不会创建或更改远程分支，只是简单的上传代码。</p>
</li>
<li>
<p>查看当前配置有哪些仓库，可以加上 -v 参数来显示所有的仓库别名的实际连接地址</p>
<p><code>git remote [-v]</code></p>
</li>
</ul>
<h5 id="提取远程仓库"><a class="header-anchor" href="#提取远程仓库">¶</a>提取远程仓库</h5>
<ol>
<li>先使用 <code>git fetch [仓库名] [分支名]</code> 将远程仓库的分支下载到本地主机，因为时拉取，所以需要指定远程仓库名和分支名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch origin main</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 996 bytes | 90.00 KiB/s, done.</span><br><span class="line">From gitee.com:Zero_Li_Fun/Decimal-conversion</span><br><span class="line"> * branch            main       -&gt; FETCH_HEAD</span><br><span class="line">   dfb4d6e..9d5cf43  main       -&gt; origin/main</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后使用 <code>git merge [origin/master]</code> 来合并远程分支到本地的当前分支，合并分支要指定被合并的分支名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge origin/main</span><br><span class="line">Updating dfb4d6e..9d5cf43</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>
<h5 id="删除远程仓库"><a class="header-anchor" href="#删除远程仓库">¶</a>删除远程仓库</h5>
<p><code>git remote rm &lt;仓库别名&gt;</code></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2023/04/28/Java/</url>
    <content><![CDATA[<h5 id="Future"><a class="header-anchor" href="#Future">¶</a>Future</h5>
<p>此类用于异步存储计算结果</p>
<ul>
<li>
<p>方法摘要：</p>
<p><code>get()</code></p>
<ul>
<li>此方法会阻塞当前线程直到任务完成，然后检索其结果</li>
</ul>
</li>
</ul>
<p><code>get(long timeout ,TimeUnit unit)</code></p>
<ul>
<li>此方法也会阻塞当前线程，但是到指定时间后立即返回，然后检索其结果(如果任务完成)</li>
</ul>
<p><code>cancel(boolean mayInterrupt)</code></p>
<ul>
<li>使用此方法会尝试取消这个任务的运行。如果任务已经开始，并且<code>mayInterrupt</code>参数为true，那么此任务就会被中断。如果成功的执行了取消操作，则返回true</li>
</ul>
<p><code>isCancelled()</code></p>
<ul>
<li>如果任务在完成之前被取消，则返回true。</li>
</ul>
<p><code>isDone()</code></p>
<ul>
<li>如果任务结束，无论是正常完成、中途取消，还是发生异常，都返回true。</li>
</ul>
<h5 id="Runnable任务和Calable任务"><a class="header-anchor" href="#Runnable任务和Calable任务">¶</a>Runnable任务和Calable任务</h5>
<ul>
<li>
<p><code>Runnable</code></p>
</li>
<li>
<p>此方法没有返回值也不会抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被执行时没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以通过<code>Executors</code>工具类将<code>Runnable</code>转换为<code>Callable</code></p>
<ul>
<li>
<p><code>Calable</code></p>
</li>
<li>
<p>指定的泛型返回值 <code>&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt;&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> 当无法计算结果则抛出异常</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回计算结果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="提交任务"><a class="header-anchor" href="#提交任务">¶</a>提交任务</h5>
<p><code>execute()</code>和<code>submit()</code></p>
<ul>
<li>
<p><code>execute()</code></p>
<ul>
<li>此方法用于提交不需要返回值的任务，所以无法判断任务是否被执行成功</li>
</ul>
</li>
<li>
<p><code>submit()</code></p>
<ul>
<li>
<p>此方法用于提交需要返回值的任务。返回值为<code>FutureTask</code></p>
<p><code>FutureTask</code>继承自<code>Future</code></p>
<p>可以调用返回值的<code>get()</code>方法判断任务是否执行成功</p>
</li>
</ul>
</li>
</ul>
<h5 id="取消任务"><a class="header-anchor" href="#取消任务">¶</a>取消任务</h5>
<p><code>cancel(boolean mayInterrupt)</code></p>
<ul>
<li>使用此方法会尝试取消这个任务的运行。如果任务已经开始，并且<code>mayInterrupt</code>参数为true，那么此任务就会被中断。如果成功的执行了取消操作，则返回true</li>
</ul>
<h5 id="关闭线程池"><a class="header-anchor" href="#关闭线程池">¶</a>关闭线程池</h5>
<p><code>shutdown()</code>和<code>shutdowNow()</code></p>
<ul>
<li>
<p><code>shutdown</code></p>
<ul>
<li>有序关闭线程池，队列中的任务会被执行，此时线程池不会接受新的任务,此方法无返回值</li>
</ul>
</li>
<li>
<p><code>shutdowNow</code></p>
<ul>
<li>关闭线程池，中止当前正在执行的任务，队列中的任务不会执行并且返回从未开始执行的<code>list</code>列表</li>
</ul>
</li>
</ul>
<h5 id="判断线程池是否开始关闭"><a class="header-anchor" href="#判断线程池是否开始关闭">¶</a>判断线程池是否开始关闭</h5>
<p><code>isShutdown</code>和<code>isTerminated</code></p>
<ul>
<li>
<p><code>isShoudown</code></p>
<ul>
<li>调用<code>shutdown</code>或<code>shutdownNow</code>语句后就返回<code>true</code> , 此时线程池可能并没有完全关闭( 队列中可能还有待执行的任务 )</li>
</ul>
</li>
<li>
<p><code>isTerminated</code></p>
<ul>
<li>调用<code>shutdown</code>或<code>shutdownNow</code>语句后返回<code>true</code> , 此时线程池及队列中的任务应该都已执行完毕,否则返回<code>false</code></li>
</ul>
</li>
</ul>
<h5 id="线程池"><a class="header-anchor" href="#线程池">¶</a>线程池</h5>
<ul>
<li><code>ThreadPoolExecutor</code>线程池创建的构造方法( 其它构造方法都是在此基础上的衍生 )</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          //保留的核心线程数，定义了最小可以同时运行的线程数量</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          //当队列中的任务达到队列容量时当前可以同时运行的线程数变成最大线程数量</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          //当线程数大于核心线程数时，多余空闲线程在死亡之前等待新任务的最大时长</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                          //keepAliveTime的时间单位</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          //任务队列，用来保存等待执行的任务，当新任务被提交的时候先判断当前运行的线程数是否达到了核心线程数，达到的话就存入队列</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          //创建新线程时使用的工厂方法</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">                          //拒绝策略，当任务过多而拒绝执行时使用的处理程序</span></span><br><span class="line"><span class="params">                         )</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//判断参数是否为非法或不适当的参数，为true抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//判断参数是否为null等非法参数，为true抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()););</span><br><span class="line">        <span class="type">var</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        	<span class="number">5</span>,<span class="comment">//核心线程数</span></span><br><span class="line">            <span class="number">10</span>,<span class="comment">//最大线程数</span></span><br><span class="line">            <span class="number">1L</span>,<span class="comment">//等待时间</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">//时间单位</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">100</span>),<span class="comment">//队列长度</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<span class="comment">//拒绝策略</span></span><br><span class="line">        );</span><br><span class="line">        threadPoolExecutor.execute(t);<span class="comment">//使用execute提交任务</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">v</span> <span class="operator">=</span> threadPoolExecutor.sumit(t);<span class="comment">//使用sumit提交任务</span></span><br><span class="line">        threadPoolExecutor.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="时间值单位"><a class="header-anchor" href="#时间值单位">¶</a>时间值单位</h5>
<p><code>TimeUnit</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>DAYS</code></td>
<td style="text-align:center">时间单位代表二十四小时</td>
</tr>
<tr>
<td style="text-align:center"><code>HOURS</code></td>
<td style="text-align:center">时间单位代表六十分钟。</td>
</tr>
<tr>
<td style="text-align:center"><code>MICROSECONDS</code></td>
<td style="text-align:center">时间单位代表千分之一毫秒。</td>
</tr>
<tr>
<td style="text-align:center"><code>MILLISECONDS</code></td>
<td style="text-align:center">时间单位代表千分之一秒。</td>
</tr>
<tr>
<td style="text-align:center"><code>MINUTES</code></td>
<td style="text-align:center">时间单位代表六十秒。</td>
</tr>
<tr>
<td style="text-align:center"><code>NANOSECONDS</code></td>
<td style="text-align:center">时间单位代表千分之一微秒。</td>
</tr>
<tr>
<td style="text-align:center"><code>SECONDS</code></td>
<td style="text-align:center">时间单位代表一秒。</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript笔记 - 1</title>
    <url>/2023/11/22/JavaScript%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="说明"><a class="header-anchor" href="#说明">¶</a>说明</h3>
<blockquote>
<p>因本人主学<code>Java</code>,所以下文包括以后的笔记绝大部分都是与Java做对比</p>
</blockquote>
<hr>
<h3 id="概览"><a class="header-anchor" href="#概览">¶</a>概览</h3>
<p>JavaScript 的类型有</p>
<ul>
<li><code>Number</code> (数字)</li>
<li><code>String</code> (字符串)</li>
<li><code>Boolean</code> (布尔值)</li>
<li><code>Symbol</code> (符号)</li>
<li><code>Object</code> (对象)
<ul>
<li><code>Function</code> (函数)</li>
<li><code>Array</code> (数组)</li>
<li><code>Date</code> (日期)</li>
<li><code>RegExp</code> (正则表达式)</li>
</ul>
</li>
<li><code>null</code> (空)</li>
<li><code>undefined</code> (未定义)</li>
</ul>
<p>注：在 <code>JavaScript</code> 中，所有的类型都是对象</p>
<h4 id="数据类型"><a class="header-anchor" href="#数据类型">¶</a>数据类型</h4>
<h5 id="变量-常量"><a class="header-anchor" href="#变量-常量">¶</a>变量 &amp; 常量</h5>
<p>在 2015 年之前，使用 <code>var</code> 定义变量，但在 2015 年之后，ES 6 新增了两个关键字 ：<code>lei</code> 、<code>const</code></p>
<p><code>var</code> 声明的变量在全局都能使用，但是注意，如果在代码块外声明了变量，然后在代码块中声明了同名的变量，在代码块外的变量就会被重新定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span> ;</span><br><span class="line"><span class="comment">//此处输出 x 为 10</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">var</span> x = <span class="number">2</span> ;</span><br><span class="line">    <span class="comment">//此处输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"><span class="comment">//此处输出 x 为 2</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>2</p>
</blockquote>
<p><code>let</code> 声明的变量只在 <code>let</code> 命令所在的代码块有效，即 <code>let</code> 所在的花括号内</p>
<p><code>const</code> 声明的对象为基本类型（数字，字符串，布尔值等），那么它就是常量，即不可更改的。但是也是相对的，如果它的值为一个复合类型，那么它的值就是可变的，可以修改它的属性或元素</p>
<blockquote>
<p><code>let</code> 和 <code>const</code> 都是块级作用域，即只在声明所在的代码块中有效</p>
</blockquote>
<h5 id="数字"><a class="header-anchor" href="#数字">¶</a>数字</h5>
<p>与 Java 不一样，JavaScript 没有整数(<code>int</code>)亦或者整型(<code>Integer</code>)，除了 <code>BigInt</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">3</span> / <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1.5</p>
<p>1</p>
</blockquote>
<p>JavaScript 提供了两个内置函数用于将字符串转换为整型和将浮点数转换为整型</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>parseInt(String str , Number radix)</code></td>
<td style="text-align:center">接收两个参数，<code>str</code>为要转换的字符串，<code>radix</code>为目标整数的基进制，返回转换后的指定进制数</td>
</tr>
<tr>
<td style="text-align:center"><code>parseFloat(String str)</code></td>
<td style="text-align:center">接收一个参数，<code>str</code> 为要转换的字符串，返回转换后的十进制数</td>
</tr>
</tbody>
</table>
<p>要转换字符串为整数也可以使用一元运算符 <code>'+'</code>。</p>
<p>如果给定的字符串没有 <code>Number</code>(数值)类型，那么此时就会返回一个 <code>NaN</code>(Not a Number的缩写) 值</p>
<p>除了 <code>NaN</code>，JavaScript 还提供了两个特殊值，<code>Infinity</code>(正无穷) 和 <code>-Infinity</code>(负无穷)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">    name : <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    id : <span class="string">&quot;1234&quot;</span>, </span><br><span class="line">    str : <span class="string">&quot;1234.567&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(list.<span class="property">id</span>,<span class="number">10</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseFloat</span>(list.<span class="property">str</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(list.<span class="property">name</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>1234</p>
<p>1234.567</p>
<p>123</p>
<p>NaN</p>
</blockquote>
<p>可以使用 <code>isNaN()</code> 来判断一个变量是否为 <code>NaN</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>true</p>
</blockquote>
<p>可以使用 <code>isFinite()</code> 来判断一个变量是否为一个有穷数，如果值为 <code>Infinity</code>、<code>-Infinity</code> 或 <code>NaN</code> ，那么就返回 <code>false</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(-<span class="title class_">Infinity</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="title class_">NaN</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>false</p>
<p>false</p>
<p>false</p>
</blockquote>
<blockquote>
<p>小知识1：使用 <code>parseInt()</code> 及 <code>parseFloat()</code> 时，这两个函数回尝试逐个解析字符串中的字符，直到遇到一个无法被解析的字符，然后返回该字符之前所有数字组成的数字。</p>
</blockquote>
<blockquote>
<p>小知识2：使用单目运算符 <code>'+'</code> 来转换字符串时，只要字符串中包含无法转换的字符，就会返回 <code>NaN</code></p>
</blockquote>
<h5 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h5>
<blockquote>
<p>在 JavaScript 中，所有字符串都是一串 <code>Unicode</code>字符序列。更准确的说，它是一串 <code>UTF-16</code> 编码单元的序列，每一个编码单元由一个 16 位二进制数表示。每一个 <code>Unicode</code>字符由一个或两个编码单元表示。</p>
</blockquote>
<p>在 JavaScript 中，<code>String</code> 是一个对象，因此你可以像操作普通对象一样对它进行操作。</p>
<p>使用 <code>length</code> 方法获取它的长度，使用 <code>charAt(0)</code> 返回第一个字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>5</p>
<p>h</p>
</blockquote>
<h5 id="其他类型"><a class="header-anchor" href="#其他类型">¶</a>其他类型</h5>
<p><code>null</code> 表示一个空值，<code>undefined</code> 是一个 <code>undefined</code>(未定义)类型的对象，表示一个未初始化的值，即没有被分配空间的值。在变量声明之后并未赋值，那么它的值就是 <code>undefined</code>。</p>
<p>JavaScript 的逻辑值与 Java 中的一样，<code>false</code>、<code>0</code>、空字符串(<code>&quot;&quot;</code>)、<code>NaN</code>、<code>null</code>、<code>undefined</code> 都是 <code>false</code>，其余为 <code>true</code></p>
<p>逻辑运算符也同 Java 一样，<code>&amp;&amp;</code>(逻辑与)、<code>||</code>(逻辑或)、<code>!</code>(逻辑非)，用法也一样</p>
<p>小技巧：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title class_">CacheName</span> &amp;&amp; o.<span class="title function_">getName</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用逻辑与可以事先检测该参数是否为空，防止意外的赋值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title class_">CacheName</span> || ( <span class="title class_">CacheName</span> = o.<span class="property">getName</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用逻辑或可以在参数无效时使用默认值</p>
</blockquote>
<h4 id="控制结构"><a class="header-anchor" href="#控制结构">¶</a>控制结构</h4>
<p>JavaScript 的 <code>if</code>、<code>else if</code>、<code>while</code>、<code>do...while</code>、<code>switch</code> 都同 Java 一样，稍微有点不同的就是 <code>for</code> ，普通的 <code>for</code> 和 Java 相同，但是 <code>for...in</code> 和 <code>for...of</code> 稍微有点不同，在 Java 中，与之对应的是 <code>foreach</code>也就是增强 <code>for</code>。</p>
<h5 id="for-in"><a class="header-anchor" href="#for-in">¶</a><code>for...in</code></h5>
<p>使用 <code>for...in</code> 迭代可枚举属性，可以遍历属性名和属性值，但是无法使用 <code>for...of</code> 迭代可枚举属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">    name : <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    sex : <span class="string">&quot;男&quot;</span>,</span><br><span class="line">    age :<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> l <span class="keyword">in</span> list)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(l);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(list[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>naem</p>
<p>Tom</p>
<p>sex</p>
<p>男</p>
<p>age</p>
<p>18</p>
</blockquote>
<h5 id="for-of"><a class="header-anchor" href="#for-of">¶</a><code>for...of</code></h5>
<p>使用 <code>for...of</code> 迭代可枚举对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">&quot;name&quot;</span>,<span class="string">&quot;sex&quot;</span>,<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> l <span class="keyword">of</span> list)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(l);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(list[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<blockquote>
<p>name</p>
<p>undefined</p>
<p>sex</p>
<p>undefined</p>
<p>age</p>
<p>undefined</p>
</blockquote>
<p>注：之所以是 <code>undefined</code> 是因为 <code>list</code> 的元素并没有初始化，所有未初始化的变量一律是 <code>undefined</code></p>
<h4 id="在任意浏览器中运行"><a class="header-anchor" href="#在任意浏览器中运行">¶</a>在任意浏览器中运行</h4>
<p>在浏览器中按 <code>F12</code> 进入检查模式，然后在选项卡中找到源代码，在里面可以新建代码片段，也可以直接在控制台输入代码，然后用 <code>Ctrl+Enter</code> 运行</p>
<p><img src="https://z1.ax1x.com/2023/11/07/pilWwRS.png" alt="1" loading="lazy"></p>
<h4 id="输入输出"><a class="header-anchor" href="#输入输出">¶</a>输入输出</h4>
<p>JavaScript 并没有提供任何打印或输出函数。但可以通过不同的方式输出数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>window.alert()</code></td>
<td style="text-align:center">弹出警告窗</td>
</tr>
<tr>
<td style="text-align:center"><code>document.write()</code></td>
<td style="text-align:center">将内容写入到 HTML 文档中</td>
</tr>
<tr>
<td style="text-align:center"><code>innerHTML()</code></td>
<td style="text-align:center">将内容写入到 HTML 元素</td>
</tr>
<tr>
<td style="text-align:center"><code>console.log()</code></td>
<td style="text-align:center">将内容写入到浏览器的控制台</td>
</tr>
</tbody>
</table>
<ol>
<li>由当前页面弹出警告信息弹窗</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;你好！&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/11/11/pi8vJsJ.jpg" alt="2" loading="lazy"></p>
<ol start="2">
<li>直接将内容写入 HTML 中，如果在 HTML 文档加载完后执行 <code>document.write()</code> , 则整个页面内容将被覆盖</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;HELLO WORLD!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以将 JavaScript 直接写在 HTML 文档中 , 这时的 HTML 文档是不会被覆盖的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript练习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">				你好 世界!</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot;HELLO WORLD!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>将内容写入指定HTML元素中，覆盖原有的元素内容</li>
</ol>
<p><code>document.getElementById(&quot;demo&quot;)</code> 是使用 id 属性来查找 HTML 元素的 JavaScript 代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;哈喽&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript练习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">				你好 世界!</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span>=<span class="string">&quot;HELLO WORLD!&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>将值写到控制台</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>JavaScript练习<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">				你好 世界!</span><br><span class="line">			<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;HELLO WORLD!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">		</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/11/11/pi8vGM4.jpg" alt="3" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux2023.9.15作业</title>
    <url>/2023/09/15/Linux2023-9-15%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>题目要求：</p>
<p>1、创建用户和用户组</p>
<p>请按照以下要求创建用户、用户组：</p>
<p>新建一个名为adminuser的组，组id为40000</p>
<p>新建一个名为natasha的用户，并将adminuser作为其附属组</p>
<p>新建一个名为harry的用户，并将adminuser作为其附属组</p>
<p>新建一个名为sarah的用户，其不属于adminuser组，并将其shell设置为不可登陆shell</p>
<p>natasha、harry和sarah三个用户的密码均设置为glegunge</p>
<p>2、复制文件/etc/fstab到/var/tmp目录下，并按照以下要求配置/var/tmp/fstab文件的权限:</p>
<p>该文件的所属人为root</p>
<p>该文件的所属组为root</p>
<p>该文件对任何人均没有执行权限</p>
<p>用户natasha对该文件有读和写的权限</p>
<p>用户harry对该文件既不能读也不能写</p>
<p>所有其他用户（包括当前已有用户及未来创建的用户）对该文件都有读的权限</p>
<p>3、打包文件</p>
<p>请对/etc/sysconfig目录进行打包并用bzip2压缩，生成的文件保存为/root/sysconfig.tar.bz2</p>
<p>4、创建一个大小为500M的分区，永久挂载到/test目录下</p>
</blockquote>
<hr>
<h5 id="创建用户和用户组"><a class="header-anchor" href="#创建用户和用户组">¶</a>创建用户和用户组</h5>
<ol>
<li>新建一个名为adminuser的组，组id为40000</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">groupadd -g 40000 adminuser</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新建一个名为natasha的用户，并将adminuser作为其附属组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -G adminuser natasha</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>新建一个名为harry的用户，并将adminuser作为其附属组</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -G adminuser harry</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>新建一个名为sarah的用户，其不属于adminuser组，并将其shell设置为不可登陆shell</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -s /usr/sbin/nologin sarah</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/15/pPWsWAf.png" alt="pPWsWAf.png" loading="lazy"></p>
<ol start="5">
<li>natasha、harry和sarah三个用户的密码均设置为glegunge</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">passwd &lt;用户名&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/15/pPWsfN8.png" alt="pPWsfN8.png" loading="lazy"></p>
<p>测试：</p>
<p>查看组 id 及附属组</p>
<p><img src="https://z1.ax1x.com/2023/09/15/pPWs2HP.png" alt="pPWs2HP.png" loading="lazy"></p>
<p>测试 sarah 的 shell 登录</p>
<p><img src="https://z1.ax1x.com/2023/09/15/pPWsqH0.png" alt="pPWsqH0.png" loading="lazy"></p>
<h5 id="复制文件-etc-fstab到-var-tmp目录下，并按照以下要求配置-var-tmp-fstab文件的权限"><a class="header-anchor" href="#复制文件-etc-fstab到-var-tmp目录下，并按照以下要求配置-var-tmp-fstab文件的权限">¶</a>复制文件/etc/fstab到/var/tmp目录下，并按照以下要求配置/var/tmp/fstab文件的权限:</h5>
<p>先复制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /etc/fstab /var/tmp</span><br></pre></td></tr></table></figure>
<ol>
<li>该文件的所属人为root，该文件的所属组为root</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPW6pi8.png" alt="pPW6pi8.png" loading="lazy"></p>
<ol start="2">
<li>该文件对任何人均没有执行权限，用户natasha对该文件有读和写的权限，用户harry对该文件既不能读也不能写</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPW69JS.png" alt="pPW69JS.png" loading="lazy"></p>
<ol start="3">
<li>所有其他用户（包括当前已有用户及未来创建的用户）对该文件都有读的权限</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPWyxdP.png" alt="pPWyxdP.png" loading="lazy"></p>
<h5 id="打包文件"><a class="header-anchor" href="#打包文件">¶</a>打包文件</h5>
<ol>
<li>请对/etc/sysconfig目录进行打包并用bzip2压缩，生成的文件保存为/root/sysconfig.tar.bz2</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPWyzIf.png" alt="pPWyzIf.png" loading="lazy"></p>
<h5 id="创建分区"><a class="header-anchor" href="#创建分区">¶</a>创建分区</h5>
<ol>
<li>创建一个大小为500M的分区</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPW26T1.png" alt="pPW26T1.png" loading="lazy"></p>
<ol start="2">
<li>使用 mkfs 将 sda4 格式化为 ext4 文件系统</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPW2wSU.png" alt="pPW2wSU.png" loading="lazy"></p>
<ol start="3">
<li>将分区挂载到 /test 目录，如果没有请自行创建</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPW2aWT.png" alt="pPW2aWT.png" loading="lazy"></p>
<ol start="4">
<li>使用开机自启实现永久挂载目录</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/15/pPW2UYV.png" alt="pPW2UYV.png" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux2023-9-18作业</title>
    <url>/2023/09/18/Linux2023-9-18%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<blockquote>
<p>题目要求：</p>
<p>1、破解centos7操作系统密码为flectrag</p>
<p>2、查找系统中文件，要求将文件大小大于5M小于10M的文件查找出来放置/findfile目录下</p>
<p>3、查找文件/usr/share/xml/iso-codes/iso_639_3.xml中包含字符串ng的所有行。<br>
将所有这些行的副本按原始顺序放在文件/root/list中。/root/list不得包含空行，<br>
且所有行必须是/usr/share/xml/iso-codes/iso_639_3.xml中原始行的确切副本</p>
<p>4、新建用户student，设置密码为flectrag</p>
<p>5、修改student用户策略，允许student组成员sudo时不需要密码</p>
</blockquote>
<hr>
<h4 id="1-0-破解-centos7-操作系统的-root-用户密码"><a class="header-anchor" href="#1-0-破解-centos7-操作系统的-root-用户密码">¶</a>1.0 破解 centos7 操作系统的 root 用户密码</h4>
<ol>
<li>先重启虚拟机，在如下图的界面按 e 键进入 edit</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4i8FH.jpg" alt="pP4i8FH.jpg" loading="lazy"></p>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4iJfA.jpg" alt="pP4iJfA.jpg" loading="lazy"></p>
<ol start="2">
<li>找到 linux16 字段，把里面的 <code>ro rhgb quiet</code> 改为 <code>rw init=/bin/sh</code>，之后按 ctrl+x 进入单用户模式</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4iNlt.jpg" alt="pP4iNlt.jpg" loading="lazy"></p>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4itSI.jpg" alt="pP4itSI.jpg" loading="lazy"></p>
<ol start="3">
<li>在该模式下输入 <code>passwd root</code> 来更改 root 密码，之后输入 touch /.autorelabel 创建文件，然后输入 exec /sbin/init 正常启动 init 进程即可</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4iGYd.jpg" alt="pP4iGYd.jpg" loading="lazy"></p>
<h4 id="2-0-查找文件1"><a class="header-anchor" href="#2-0-查找文件1">¶</a>2.0 查找文件1</h4>
<ol>
<li>首先要在根目录创建一个 <code>findfile</code> 文件夹，然后使用下面的命令来查找并复制</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /findfile</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -type f -size +5M -size -10M -exec cp &#123;&#125; /findfile \;</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4kyMq.png" alt="pP4kyMq.png" loading="lazy"></p>
<ol start="2">
<li>可以使用 <code>ll</code> 命令验证大小</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4ApQI.png" alt="pP4ApQI.png" loading="lazy"></p>
<h4 id="3-0-查找文件2"><a class="header-anchor" href="#3-0-查找文件2">¶</a>3.0 查找文件2</h4>
<ol>
<li>先在用户的家目录下用 <code>touch</code> 命令创建 <code>list</code> 文件，然后使用下面的命令完成要求，最后使用 <code>cat list</code> 来验证</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch list</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;ng&quot; /usr/share/xml/iso-codes/iso_639_3.xml | tr -d &#x27;\r&#x27; &gt; /root/list</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat list</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4AGY4.png" alt="pP4AGY4.png" loading="lazy"></p>
<h4 id="4-0-创建用户"><a class="header-anchor" href="#4-0-创建用户">¶</a>4.0 创建用户</h4>
<ol>
<li>使用下面的命令创建 student 用户并指定其密码，使用普通用户 sir 登录测试</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">useradd -p $(openssl passwd -1 flectrag) student</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4e3uR.png" alt="pP4e3uR.png" loading="lazy"></p>
<h4 id="5-0-修改用户策略"><a class="header-anchor" href="#5-0-修改用户策略">¶</a>5.0 修改用户策略</h4>
<ol>
<li>先使用下面的命令将 student 用户添加到 /etc/sudoers 文件中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;%student ALL=(ALL) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>然后切换到 student 用户，之后使用 sudo passwd root 来试着更改 root 用户的密码，可以看到，可以直接更改，不需要输入密码，然后切到 sir 普通用户，同样试着更改 root 用户的密码，可以看到，无法更改</p>
<p><img src="https://z1.ax1x.com/2023/09/18/pP4e8D1.png" alt="pP4e8D1.png" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mermaid画图测试</title>
    <url>/2023/04/29/Mermaid%E7%94%BB%E5%9B%BE%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h4 id="流程图"><a class="header-anchor" href="#流程图">¶</a>流程图</h4>
<ul>
<li>语法解释:<code>graph</code>表示声明一张流程图 <code>TD</code>表示方向 T(top)-D(down) 由上至下 <code>()</code>表示圆形框 <code>&#123;&#125;</code>表示菱形框</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">	A--&gt;B(B);</span><br><span class="line">	A--&gt;C;</span><br><span class="line">	B--&gt;D&#123;D&#125;;</span><br><span class="line">	流程图</span><br></pre></td></tr></table></figure>
<h5 id="时序图"><a class="header-anchor" href="#时序图">¶</a>时序图</h5>
<ul>
<li>语法解释:<code>-&gt;&gt;代表实线箭头</code>  <code>--&gt;&gt;代表虚线箭头</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">	A-&gt;&gt;J: hello J!</span><br><span class="line">	J--&gt;&gt;A: good!</span><br></pre></td></tr></table></figure>
<h5 id="状态图"><a class="header-anchor" href="#状态图">¶</a>状态图</h5>
<ul>
<li>语法解释:<code>[*]代表开始或结束</code> 如果在箭头右边则表示结束</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram</span><br><span class="line">	[*] --&gt; s</span><br><span class="line">	s --&gt;[*]</span><br></pre></td></tr></table></figure>
<h5 id="类图"><a class="header-anchor" href="#类图">¶</a>类图</h5>
<ul>
<li>语法解释:<code>&lt;|--</code>表示继承 <code>+</code>表示<code>public</code> <code>-</code>表示<code>private</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">	A &lt;|-- D</span><br><span class="line">	A &lt;|-- F</span><br><span class="line">	A : + int a</span><br><span class="line">	A : + toString()</span><br><span class="line">	class D&#123;</span><br><span class="line">		+ String S</span><br><span class="line">		+ setS()</span><br><span class="line">	&#125;</span><br><span class="line">	class F&#123;</span><br><span class="line">		- char c</span><br><span class="line">		- getC()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="饼图"><a class="header-anchor" href="#饼图">¶</a>饼图</h5>
<ul>
<li>语法解释:饼图使用<code>pie</code>表示 标题下面分别是区域名称及其所占百分比</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie</span><br><span class="line">	title 每日时间分配</span><br><span class="line">	&quot;睡觉&quot; : 40</span><br><span class="line">	&quot;学习&quot; : 25</span><br><span class="line">	&quot;吃饭刷视频&quot; : 15</span><br><span class="line">	&quot;生活杂事&quot; : 20</span><br></pre></td></tr></table></figure>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>mermaid</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora的破解</title>
    <url>/2023/11/07/Typora%E7%9A%84%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="前言（废话）"><a class="header-anchor" href="#前言（废话）">¶</a>前言（<s>废话</s>）</h4>
<p>介绍一下 Typora 是什么…</p>
<blockquote>
<p>下面是引用自百度百科的话：</p>
<p>Typora 是一款由 Abner Lee 开发的<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835?fromModule=lemma_inlink">轻量级</a> Markdown 编辑器，与其他 Markdown 编辑器不同的是，Typora 没有采用<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3969?fromModule=lemma_inlink">源代码</a>和预览双栏显示的方式，而是采用所见即所得的编辑方式，实现了即时预览的功能，但也可切换至源代码编辑模式。</p>
</blockquote>
<p>看完之后你说你不知道 Markdown 是什么？</p>
<blockquote>
<p>Markdown 是一种<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/52671915?fromModule=lemma_inlink">轻量级标记语言</a>，创始人为约翰·格鲁伯（John Gruber）。 它允许人们使用易读易写的<a href="https://baike.baidu.com/item/%E7%BA%AF%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/9862288?fromModule=lemma_inlink">纯文本格式</a>编写文档，然后转换成有效的 <a href="https://baike.baidu.com/item/XHTML/316621?fromModule=lemma_inlink">XHTML</a>（或者HTML）文档。这种语言吸收了很多在<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106?fromModule=lemma_inlink">电子邮件</a>中已有的纯文本标记的特性。</p>
<p>由于 Markdown 的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。 如 <a href="https://baike.baidu.com/item/GitHub/10145341?fromModule=lemma_inlink">GitHub</a>、<a href="https://baike.baidu.com/item/Reddit/1272010?fromModule=lemma_inlink">Reddit</a>、<a href="https://baike.baidu.com/item/Diaspora/10726893?fromModule=lemma_inlink">Diaspora</a>、[Stack Exchange](<a href="https://baike.baidu.com/item/Stack">https://baike.baidu.com/item/Stack</a> Exchange/13777796?fromModule=lemma_inlink)、<a href="https://baike.baidu.com/item/OpenStreetMap/3171606?fromModule=lemma_inlink">OpenStreetMap</a> 、<a href="https://baike.baidu.com/item/SourceForge/6562141?fromModule=lemma_inlink">SourceForge</a>、简书等，甚至还能被使用来撰写<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E4%B9%A6/346054?fromModule=lemma_inlink">电子书</a>。</p>
</blockquote>
<p>好了，现在你应该有一个大概的了解了，那么请继续看破解教程</p>
<h4 id="下载-Typora"><a class="header-anchor" href="#下载-Typora">¶</a>下载 Typora</h4>
<p>先到官网下最新版的 Typora 软件，然后安装，先别管激活</p>
<blockquote>
<p>官网: <a href="https://typora.io/">Typora</a></p>
</blockquote>
<h4 id="破解"><a class="header-anchor" href="#破解">¶</a>破解</h4>
<ol>
<li>下载要用的破解软件。</li>
</ol>
<blockquote>
<p>思路：使用伪造的激活码来激活</p>
<p>破解程序在 Github 上有，需要克隆( 下载 )两个仓库，克隆下来并不能直接使用，要使用 Rust 编译为 exe 文件。</p>
<p>或者你可以直接使用我提供的已经编译好的破解程序（要自己编译的话要安装及配置 Rust，麻烦）。</p>
<p>编译教程：<a href="https://github.com/moxiaobei1993/blog/issues/8">一劳永逸破解 Typora 全系列</a></p>
<p>仓库一：<a href="https://github.com/DiamondHunters/NodeInject">DiamondHunters/NodeInject</a></p>
<p>仓库二：<a href="https://github.com/DiamondHunters/NodeInject_Hook_example">DiamondHunters/NodeInject_Hook_example</a></p>
<p><a href="https://8.222.153.91:39811/down/PgojgcfGwmXp.7z">exe 下载链接</a>：提取码:YunYi	注：提取码大小写敏感</p>
</blockquote>
<ol start="2">
<li>
<p>下载完之后在将压缩包里的文件直接提到你安装的 Typora 的根目录里（就是有 Typora.exe 文件的文件夹里，实在找不到那就直接右键桌面的 Typora 图标，然后属性，你就能看到安装的位置了）</p>
</li>
<li>
<p>然后 Typora 根目录里的 run.bat 双击运行即可</p>
</li>
<li>
<p>你会在弹出的 CMD 命令行中看到如下的内容：</p>
</li>
</ol>
<blockquote>
<p>License for you: <code>CLX2WZ-WLQ7DP-PJPNGT-9AKLDL</code></p>
</blockquote>
<p>其中的 <code>CLX2WZ-WLQ7DP-PJPNGT-9AKLDL</code> 字段就是你要用的“激活码”(伪)</p>
<ol start="5">
<li>
<p>之后你打开 Typora 软件，它应该会弹出激活或者试用页面，选择激活</p>
</li>
<li>
<p>它会让你输入两次邮箱，你直接用个临时邮箱即可（临时邮箱的获取可以在我以前的安利文章里找到），第二个邮箱跟第一个填一样的，注意，这个邮箱要你自己手动输入，不能复制粘贴</p>
</li>
<li>
<p>填入你的“激活码”，然后激活</p>
</li>
<li>
<p>第一次激活的时候它会提示你<code>链接服务器失败，使用尝试访问国内域名进行激活</code>，不用管，点确认就可以了，或者关掉重新激活一下就行</p>
</li>
</ol>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>markdown</tag>
        <tag>破解</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Win至Linux的免密登录</title>
    <url>/2023/09/09/Win%E8%87%B3Linux%E7%9A%84%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h4 id="配置-Windows-端"><a class="header-anchor" href="#配置-Windows-端">¶</a>配置 Windows 端</h4>
<ol>
<li>先在 Windows 下生成公钥文件</li>
</ol>
<p>使用 win+R 打开运行对话框，输入 cmd 打开命令提示符（或者随便打开一个文件夹 --&gt; 右键 --&gt; 在终端中打开）</p>
<p>输入以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa</span><br></pre></td></tr></table></figure>
<p>之后无脑回车确定</p>
<p><img src="https://s1.ax1x.com/2023/09/09/pPcuprT.png" alt="powershell1" loading="lazy"></p>
<ol start="2">
<li>找到你默认存放公钥的位置</li>
</ol>
<p><img src="https://s1.ax1x.com/2023/09/09/pPcuPZF.png" alt="powershell2" loading="lazy"></p>
<ol start="3">
<li>将你生成的公钥文件传到 Linux 服务器上</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scp 你公钥存放的位置/.ssh/id_rsa.pub  你要登录的用户名<span class="selector-tag">@</span>你服务器的ip:~/.ssh</span><br></pre></td></tr></table></figure>
<p>上传完毕之后 Windows 端的配置就完成了</p>
<h4 id="配置-Linux-端"><a class="header-anchor" href="#配置-Linux-端">¶</a>配置 Linux 端</h4>
<ol>
<li>先登录到 Linux 服务器</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh root<span class="selector-tag">@</span>你服务器的ip</span><br></pre></td></tr></table></figure>
<p>在输入密码后就能登录上去</p>
<ol start="2">
<li>在当前用户家目录下找到 <code>.ssh</code> 文件夹</li>
</ol>
<p>使用以下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure>
<p>然后使用以下命令将 <code>id_rsa.pub</code> 文件的内容追加到 <code>authorized_keys</code> 中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>然后用 <code>chmod</code> 修改文件的权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 600 .ssh/authorized_keys</span><br><span class="line">chmod 700 .ssh</span><br></pre></td></tr></table></figure>
<h5 id="修改SSH的配置文件"><a class="header-anchor" href="#修改SSH的配置文件">¶</a>修改SSH的配置文件</h5>
<ol>
<li>使用以下命令进入 <code>ssh</code> 的配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>找到下面的三句不被注释掉，没有直接添加</li>
</ol>
<p>温馨提示：可以使用 <code>斜杠“/”</code> 来快速查找</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RSAAuthentication yes </span><br><span class="line">PubkeyAuthentication yes </span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>然后 <code>:wq</code> 保存并退出</p>
<ol start="3">
<li>使用以下命令重启SSH服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>
<h4 id="测试免密登录"><a class="header-anchor" href="#测试免密登录">¶</a>测试免密登录</h4>
<p>在 Windows 的 power shell 上输入以下命令：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh root<span class="selector-tag">@</span>你服务器的ip</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/09/pPcQcQI.png" alt="powershell3" loading="lazy"></p>
<p>可以看到，直接连上了服务器，到这你的免密登录就成功了</p>
<h4 id="使用指定端口登录"><a class="header-anchor" href="#使用指定端口登录">¶</a>使用指定端口登录</h4>
<p>一般来说，为了服务器的安全起见，我们都会更改 SSH 的默认登录端口</p>
<p>可以在服务器 ip 后加 -p 参数来指定要使用的端口</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>计算机知识</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>电脑技术</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的使用-贰</title>
    <url>/2023/09/05/docker%E7%9A%84%E4%BD%BF%E7%94%A8-%E8%B4%B0/</url>
    <content><![CDATA[<h4 id="Docker容器的应用"><a class="header-anchor" href="#Docker容器的应用">¶</a>Docker容器的应用</h4>
<blockquote>
<p>前言：使用Docker部署nginx站点实现外网访问</p>
</blockquote>
<p>1.先创建一个nginx站点</p>
<blockquote>
<p><code>docker run --name nginx-one -itd -P nginx:latest</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/05/pPsFU6s.png" alt="nginx1" loading="lazy"></p>
<p>2.将本地的<code>./nginx/www</code>、<code>./nginx/logs</code>、<code>./nginx/conf</code>分别挂载到容器的<code>/usr/share/nginx/html</code>、<code>/var/log/nginx</code>、<code>/etc/nginx/nginx.conf</code>并且将主机端口25568映射到容器的80端口</p>
<blockquote>
<p><code>docker run -itd -p 25568:80 --name nginx-two -v /root/nginx/www:/usr/share/nginx/html -v /root/nginx/logs:/var/log/nginx -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf nginx:latest</code></p>
<p>注意：挂载之前要用<code>docker cp f9226f7ac7f7:/etc/nginx/nginx.conf ./nginx/conf/</code>命令将<code>nginx.conf</code>文件<code>copy</code>到本地，要不然会报挂载错误，使用本命令时注意将容器ID改为自己的</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/05/pPsFwmq.png" alt="nginx2" loading="lazy"></p>
<p>3.在本地的<code>/root/nginx/www</code>文件夹下创建<code>index.html</code></p>
<blockquote>
<p><code>cd /root/nginx/www; vim index.html</code></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/05/pPsFaXn.png" alt="nginx3" loading="lazy"></p>
<p>4.直接在浏览器访问你服务器的ip加之前指定的端口(由于我服务器防火墙没开放20000端口，所以用25568代替一下)</p>
<p><img src="https://s1.ax1x.com/2023/09/05/pPsFNlj.png" alt="nginx4" loading="lazy"></p>
<blockquote>
<p>点击连接访问<a href="http://8.222.153.91:25568">nginx站点</a></p>
</blockquote>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>frp之内网穿透</title>
    <url>/2023/05/08/frp%E4%B9%8B%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2023/05/01/p98QaIP.jpg" alt="p98QaIP.jpg" loading="lazy"></p>
<span id="more"></span>
<h3 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h3>
<hr>
<p>众所周知，在我大内网环境里，你没有公网ip想要别人能够访问你电脑的内容是不可能的（除非你利用一些第三方的软件，但是第三方软件往往有一些限制，比如带宽啊，流量啊，收费啊等等）</p>
<p>而你利用frp反向代理就可以在你没有公网ip的情况下实现别人访问你电脑的内容。</p>
<ul>
<li>
<p>frp是什么</p>
<p>用百度百科的解释</p>
<blockquote>
<p>高性能反向代理应用<br>
frp 是一个高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p>
</blockquote>
<p>这是官方的解释</p>
<blockquote>
<p>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p>
</blockquote>
</li>
</ul>
<p>官方的解释往往有些不是很通俗易懂（毕竟是官方嘛）</p>
<p>其实<code>frp</code>就是利用一台有公网<code>ip</code>的服务器来进行端口转发（所以说使用<code>frp</code>前你要有一台云服务器或<code>vps</code>，因为云服务器或<code>vps</code>一般都有公网<code>ip</code>），这么说吧，你首先要在云服务器装一个<code>frps</code>（服务器端的程序），然后再本地装一个<code>frpc</code>（客户端程序，本地指的是你要访问的内网机器），之后你再配置好他们的端口映射关系（比如说你把云服务器端的<code>23333</code>端口开放了，然后在本地把你要访问的服务的端口也打开，就比如说<code>http</code>的<code>80</code>端口，然后在程序里将它们的映射关系 配置好），这个时候你访问有公网<code>ip</code>的服务器的指定端口（上面开放的<code>23333</code>），服务器端的程序<code>frps</code>就会把这个访问请求转发到它映射到客户端的端口（上面说的<code>80</code>），这个时候你就实现了在没有公网<code>ip</code>的情况下让别人访问你电脑的内容。</p>
<p>有人会说你云服务器不是有公网<code>ip</code>嘛，为什么不用？</p>
<p>首先，你对这个服务器的公网<code>ip</code>没有使用权，你有使用这个服务器的权力，这个公网<code>ip</code>的使用权在服务器手里。</p>
<hr>
<h4 id="具体如何操作"><a class="header-anchor" href="#具体如何操作">¶</a>具体如何操作</h4>
<blockquote>
<p>2023.5.22更新，最近是真的懒，一点都不想动</p>
</blockquote>
<p>1.首先你要前往它的官方GitHub库下载最新的程序（<s>废话</s>）</p>
<blockquote>
<p><a href="https://github.com/fatedier/frp/releases">Releases · fatedier/frp (github.com)</a></p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/05/22/p9I2ZnJ.png" alt="p9I2ZnJ.png" loading="lazy"></p>
<p>可以看到，有很多版本，至于下哪个，看你要穿透的内网主机和当作穿透服务器的云服务器是什么<code>cpu</code>架构了，比如我电脑<code>windows</code>系统，<code>cpu</code>是<code>x64</code>架构的，那就选<code>windows_amd64的</code>，而我的服务器是装的<code>Linux</code>，<code>cpu</code>是<code>x86_64</code>架构，那就选<code>Linux_amd64</code>，至于<code>macos</code>的，我身边也没有人用<code>macos</code>系统的，所以请自行查阅资料吧</p>
<p>在命令行使用命令查看</p>
<blockquote>
<p>Windows</p>
</blockquote>
<p>在<code>cmd</code>（命令提示框中）中输入：<code>systeminfo</code></p>
<p><img src="https://s1.ax1x.com/2023/05/22/p9IREPP.png" alt="p9IREPP.png" loading="lazy"></p>
<blockquote>
<p>Linux</p>
</blockquote>
<p>同样在命令行中输入：<code>lscpu</code></p>
<p><img src="https://s1.ax1x.com/2023/05/22/p9I4tYR.png" alt="p9I4tYR.png" loading="lazy"></p>
<p>至于<code>x64</code>和<code>x86_64</code>，它们其实是指<code>cpu</code>的指令集架构，<code>cpu</code>指令集目前主要是分为两大类</p>
<p>​	1.复杂指令集</p>
<p>​		复杂指令集主要是<code>Intel</code>和<code>AMD</code>的<code>cpu</code>在使用，复杂指令集分为<code>x86</code>、<code>x64</code>，如果你的电脑是<code>32</code>位操作系统（现在应该没有用<code>32</code>位系统的吧），那就是<code>x86</code>的（为什么叫<code>x86</code>而不是<code>x32</code>,那是因为早期的处理器名称都是以数字<code>86</code>结尾，因此其架构被称为<code>x86</code>），如果是<code>64</code>位系统，那就是<code>x64</code></p>
<p>​		现在复杂指令集架构的<code>cpu</code>大多应用在<code>pc</code>机上，包括<code>Windows</code>、<code>Linux</code>、<code>MacOS</code></p>
<p>​	2.简单指令集</p>
<p>​		简单指令集是<code>arm</code>的一种架构，这种架构的<code>cpu</code>主要是应用在手机上，包括安卓和苹果</p>
<p>知道改下哪个架构的程序之后就可以下载了，但是注意，程序下载下来之后是包含服务器端和客户端的，<code>frps</code>是服务器端的程序，<code>frpc</code>是客户端的程序</p>
<p>比如说你下载了<code>windouws</code>的程序，它里面是包含服务器端程序和客户端程序，看你需要哪一端的程序吧，另外一端可以删了（当时我也是在这卡了一会儿）</p>
<p><img src="https://s1.ax1x.com/2023/05/22/p9Ior0U.png" alt="p9Ior0U.png" loading="lazy"></p>
<h4 id="关于配置问题"><a class="header-anchor" href="#关于配置问题">¶</a>关于配置问题</h4>
<p><b>注意：由于官方配置文件发生改变，以下配置文件仅供参考</b></p>
<p>配置文件是*.ini为结尾的文件，服务器端的程序和客户端的程序都要配置</p>
<blockquote>
<p><a href="https://gofrp.org/zh-cn/docs/examples/ssh/">通过 SSH 访问内网机器 | frp (gofrp.org</a> 官方配置参考</p>
</blockquote>
<ul>
<li>客户端配置</li>
</ul>
<p><img src="https://s1.ax1x.com/2023/05/22/p9I7Us0.png" alt="p9I7Us0.png" loading="lazy"></p>
<ul>
<li>
<p>服务器端配置</p>
<p><img src="https://s1.ax1x.com/2023/05/22/p9I72sx.png" alt="p9I72sx.png" loading="lazy"></p>
</li>
</ul>
<h4 id="新版配置文件模板"><a class="header-anchor" href="#新版配置文件模板">¶</a>新版配置文件模板</h4>
<p>服务器端（frps.toml）:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bindPort 是 frp 程序通信使用的端口</span></span><br><span class="line"><span class="attr">bindPort</span> = <span class="number">7000</span></span><br><span class="line"><span class="comment"># token 用于验证客户端的正确性</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br></pre></td></tr></table></figure>
<p>客户端（frpc.toml）：</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># serverAddr 是你公网服务器的 IP</span></span><br><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;x.x.x.x&quot;</span></span><br><span class="line"><span class="comment"># serverPort 是客户端和服务器端的通信端口，客户端和服务器端要保持一致</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"><span class="comment"># token 填和服务器端相同的 token</span></span><br><span class="line"><span class="attr">token</span> = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="comment"># 你要穿透的服务的名称，如：ssh</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;ssh&quot;</span></span><br><span class="line"><span class="comment"># 穿透使用的协议 tcp or udp</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"><span class="comment"># 本机ip，默认即可</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"><span class="comment"># 本机的要穿透服务端口</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">22</span></span><br><span class="line"><span class="comment"># 服务器的访问端口</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">8022</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以配置多个服务，只需更改客户端即可</span></span><br><span class="line"><span class="comment"># 多个服务之间 name 的名字需要不同，localPort 和 remotePort 都需要与之前的不同</span></span><br><span class="line"><span class="comment"># [[proxies]]</span></span><br><span class="line"><span class="comment"># name = &quot;&quot;</span></span><br><span class="line"><span class="comment"># type = &quot;&quot;</span></span><br><span class="line"><span class="comment"># localIP = &quot;&quot;</span></span><br><span class="line"><span class="comment"># localPort = &quot;&quot;</span></span><br><span class="line"><span class="comment"># remotePort = </span></span><br></pre></td></tr></table></figure>
<h4 id="启动-frp"><a class="header-anchor" href="#启动-frp">¶</a>启动 frp</h4>
<h5 id="frps"><a class="header-anchor" href="#frps">¶</a>frps</h5>
<ol>
<li>安装 <code>systemd</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 yum 安装，适用于 CentOS 和 RHEL</span></span><br><span class="line">yum install systemd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 apt 安装，适用于 Debian 和 Ubuntu</span></span><br><span class="line">apt install systemd</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建 frps.service 文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 vim 在 /etc/systemd/system/ 下创建</span></span><br><span class="line">sudo vim /etc/systemd/system/frps.service</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如报错可以试一下取消 sudo</span></span><br></pre></td></tr></table></figure>
<p>然后写入以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称，可自定义</span></span><br><span class="line">Description = frp server</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动frps的命令，需修改为您的frps的安装路径，如：/root/frp/frps -c /root/frp/frps.toml</span></span><br><span class="line">ExecStart = /path/to/frps -c /path/to/frps.toml</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure>
<p>配置完之后就可以直接使用 <code>systemctl start frps</code> 来启动 <code>frps</code> 服务</p>
<h5 id="frpc"><a class="header-anchor" href="#frpc">¶</a>frpc</h5>
<p>在<code>frp</code>的安装目录下输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./frpc -c ./frpc.toml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果出现了 Illegal instruction 报错那就是你版本没选对</span></span><br></pre></td></tr></table></figure>
<h4 id="常用的-systemctl-命令："><a class="header-anchor" href="#常用的-systemctl-命令：">¶</a>常用的 <code>systemctl </code> 命令：</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动程序</span></span><br><span class="line">systemctl start frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看程序状态</span></span><br><span class="line">systemctl status frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止程序</span></span><br><span class="line">systemctl stop frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动</span></span><br><span class="line">systemctl restart frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭开机启动</span></span><br><span class="line">systemctl disable frps</span><br></pre></td></tr></table></figure>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>harbor本地仓库搭建</title>
    <url>/2023/09/12/harbor%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h4 id="创建-Harbor-仓库"><a class="header-anchor" href="#创建-Harbor-仓库">¶</a>创建 Harbor 仓库</h4>
<ol>
<li>访问官方网站下载官方镜像源</li>
</ol>
<blockquote>
<p>官方网站： <a href="https://goharbor.io/">Harbor (goharbor.io)</a></p>
</blockquote>
<ol start="2">
<li>使用 scp 将下载的官方镜像上传到服务器</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scp <span class="literal">-P</span> <span class="number">2000</span> .\harbor<span class="literal">-offline-installer-v2</span>.<span class="number">7.3</span>.tgz root<span class="selector-tag">@</span>你服务器的ip:/root/</span><br></pre></td></tr></table></figure>
<p>注：使用 -P 参数可以指定 scp 的端口号</p>
<p><img src="https://s1.ax1x.com/2023/09/12/pPg4W1U.png" alt="pPg4W1U.png" loading="lazy"></p>
<ol start="3">
<li>使用下面的命令解压文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf harbor-offline-installer-v2.7.3.tgz</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用 vim 更改 harbor.yml.tmep 的内容</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim harbor.yml.tmep</span><br></pre></td></tr></table></figure>
<p>将 hostname 修改为自己的 ip 地址，然后将 https 全部注释掉，同时也可以更改密码</p>
<p><img src="https://s1.ax1x.com/2023/09/12/pPgHXgP.png" alt="pPgHXgP.png" loading="lazy"></p>
<ol start="5">
<li>使用 yum 下载 epel-release 及 docker-compose</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release ; yum -y install docker-compose</span><br></pre></td></tr></table></figure>
<p>注：由于不可抗力的原因（我服务器带不动 [倒] ），下面的所有演示都是在我室友的虚拟机上完成的</p>
<p><img src="https://s1.ax1x.com/2023/09/12/pPgORaD.png" alt="pPgORaD.png" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/09/12/pPgO2VO.png" alt="pPgO2VO.png" loading="lazy"></p>
<ol start="6">
<li>安装 harbor</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv ./harbor.yml.tmep ./harbor.yml ; ./install.sh</span><br></pre></td></tr></table></figure>
<p>注：安装之前请先将 harbor.yml.tmep文件改为 harbor.yml ，要不然会找不到文件</p>
<p><img src="https://s1.ax1x.com/2023/09/12/pPgXj0K.png" alt="pPgXj0K.png" loading="lazy"></p>
<ol start="7">
<li>在浏览器中访问</li>
</ol>
<p>在浏览器中输入：</p>
<blockquote>
<p>你的IP/harbor</p>
<p>由于我用的是室友的电脑中的虚拟机来做的，在我电脑上是直接访问不到虚拟机里的，所以做了个 net 端口转发使我电脑能够访问，你们在自己的浏览器中就不需要输入端口号了，默认 80</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/12/pPgjrB6.png" alt="pPgjrB6.png" loading="lazy"></p>
<ol start="8">
<li>输入账号密码</li>
</ol>
<blockquote>
<p>账号默认为 admin，密码默认为Harbor12345，如果你更改了默认密码那就填你改的密码</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/09/12/pPgjXgs.png" alt="pPgjXgs.png" loading="lazy"></p>
<ol start="9">
<li>点击新建项目来新建一个仓库</li>
</ol>
<p><img src="https://s1.ax1x.com/2023/09/12/pPgvLdK.png" alt="pPgvLdK.png" loading="lazy"></p>
<ol start="10">
<li>修改 Docker 配置</li>
</ol>
<p>因为我使用的使 http 协议，而 docker 默认为 https，所以需要将本地私有仓库添加到信任仓库中</p>
<p>使用下面的命令修改配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
<p>注意：你在配置 daemon 文件的时候，除了最后一个键值对后面不用英文逗号，其他都要</p>
<p><img src="https://z1.ax1x.com/2023/09/13/pPRpcxe.png" alt="pPRpcxe.png" loading="lazy"></p>
<ol start="11">
<li>刷新刚刚编辑的 daemon.json 文件并重启 docker</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon.json ; systemctl restart docker</span><br></pre></td></tr></table></figure>
<ol start="12">
<li>给要推送的镜像添加 tag 标签</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag centos:centos7 192.168.100.10/zero/centos:centos7]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注：ip 后面的为你在仓库命名空间创建的仓库名</span></span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/13/pPRAdS0.png" alt="pPRAdS0.png" loading="lazy"></p>
<ol start="13">
<li>在终端登录至搭建的 harbor 私有仓库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login http://192.168.100.10 -u admin -p 123456</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/13/pPRAUWq.png" alt="pPRAUWq.png" loading="lazy"></p>
<ol start="14">
<li>使用 push 命令上传镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push 192.168.100.10/zero/centos:centos7</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/13/pPRANYn.png" alt="pPRANYn.png" loading="lazy"></p>
<ol start="15">
<li>从浏览器进入 harbor 仓库管理界面</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/13/pPRAwlV.png" alt="pPRAwlV.png" loading="lazy"></p>
<p>可以看到，已经上传到 zero 仓库了</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>原创</tag>
        <tag>harbor</tag>
      </tags>
  </entry>
  <entry>
    <title>Xmind破解</title>
    <url>/2023/11/09/Xmind%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="下载-Xmind"><a class="header-anchor" href="#下载-Xmind">¶</a>下载 Xmind</h4>
<ol>
<li>先去下载 Xmind 的最新版本</li>
</ol>
<blockquote>
<p><a href="https://xmind.cn/">Xmind思维导图 | Xmind中文官方网站</a></p>
</blockquote>
<h4 id="激活"><a class="header-anchor" href="#激活">¶</a>激活</h4>
<ol>
<li>找到你的 Xmind 的 <code>account.json</code> 文件位置（一般在 <code>C:\Users\qingtian\AppData\Roaming\Xmind\Electron v3\vana\state</code> 下）</li>
<li>将以下代码写入到 <code>account.json</code> 文件中（注意：你直接复制我文章的内容会有版权信息，请将信息删除之后再写入到文件里）</li>
</ol>
<p>然后右键此文件，选择属性，点击只读，确定保存</p>
<blockquote>
<p>{“region”:“us”,“openSignInDialogDate”:“2023-05-23T02:42:15.383Z”,“rawSubscriptionData”:“WUnYY8kQKgX3kjftuV3gnl+b7lLsBaQjZv1C8AbQBBIn9RiEkGiJGlk/9EAsI5E6uuxGTkhnf5D5Si2buztQGEaLXzVXzFzsMmdXw5fzb+Oo6I78/xNPCRfOKSOlrtOveGdYX+GZJKXJSG77/hb93Tgst5/v1BqS+PdKHwd3dMg=”}</p>
</blockquote>
<ol start="3">
<li>之后在你电脑杀毒软件中拦截 Xmind 的联网请求，由于我电脑装的是火绒，所以使用火绒演示，其他杀毒软件请自行百度</li>
</ol>
<p>打开火绒，选择安全设置 》系统防护 》 联网控制，在里面找到添加规则，输入 xmind ，选择操作方式为阻止联网，然后保存即可</p>
<h4 id="2023-12-12-更新"><a class="header-anchor" href="#2023-12-12-更新">¶</a>2023.12.12 更新</h4>
<p>经过我的测试，这个激活码大概是在 <code>2023.11.25 9:16</code> 之前有效，<code>xmind</code> 应该是通过获取系统日期，然后加密和激活码中加密过的时间进行比较来判定是否生效。</p>
<p>知道原因了，问题就好解决了，使用 <code>RunAsdate</code> 来让 <code>xmind</code> 运行在指定的时间即可。</p>
<blockquote>
<p>链接：<a href="https://zero-li.lanzout.com/iEqjz1hoph8d">RunAsdate</a><br>
密码:i50f</p>
</blockquote>
<p>程序是汉化过的，不用担心看不懂。</p>
<p>你可以使用 <code>RunAsdate</code> 创建一个指定的 <code>xmind</code> 文件快捷方式，这样就不用每次都打开 <code>RunAsdate</code>，直接使用快捷方式就行。</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>破解</tag>
        <tag>xmind</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo及SSL获取</title>
    <url>/2023/04/30/hexo%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8ASSL%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h4 id="注意：本文只记录大概过程-具体教程百度上都有"><a class="header-anchor" href="#注意：本文只记录大概过程-具体教程百度上都有">¶</a>注意：本文只记录大概过程( 具体教程百度上都有 )</h4>
<hr>
<h5 id="hexo"><a class="header-anchor" href="#hexo">¶</a>hexo</h5>
<p>这是一个开源的博客框架，你可以通过这个框架快速搭建属于你的个人博客</p>
<blockquote>
<p>官网:<a href="https://hexo.io/zh-cn/">Hexo</a></p>
</blockquote>
<p>跟着官方文档走就能搭好(大概吧)</p>
<p>搭建个人博客首先要一个托管平台，下面我就说两个常见的:</p>
<p>1.自掏腰包买个云服务器(本站就是通过这种方式搭建的)，这种方式对于我们这种搭建个人博客的群体而言并不是很划算，毕竟一个云服务器少说几十，多则上百(买了服务器，我的钱包已经瘪瘪的啦😭)</p>
<p>2.使用那些免费的托管平台，比如github pages，这个的话好处是它是免费的，但是由于它的服务器在国外，所以有点时灵时不灵的，当然，你要是挂个梯子，啥网站上不去勒🤨</p>
<p>关于hexo怎么搭建，我只说一下大致搭建流程，具体的网上的教程比我讲的详细多了，我就不多说了</p>
<p>首先你要在本地(windows)下一个node.js(应该不会有人下错吧？)，毕竟这个框架是基于这个东西运行的，至于版本最好选择大于12的版本</p>
<blockquote>
<p>官网：<a href="https://nodejs.org/zh-cn">Node.js (nodejs.org)</a>( 官网有中文版，这点还是挺不错的 )</p>
</blockquote>
<p>下载好之后直接无脑next，然后在控制台用<code>node -v;npm -v </code>检查版本来看是否安装成功</p>
<p><img src="https://s1.ax1x.com/2023/04/30/p93OgEV.png" alt="p93OgEV.png" loading="lazy"></p>
<p>下载好之后直接使用<code>npm install -g hexo-cli</code>安装hexo</p>
<p>装好之后用<code>hexo -v</code>查看版本</p>
<p>然后创建一个网站，将hexo-blog名换成你要创建的网站名称即可</p>
<p><code>hexo init hexo-blog</code></p>
<p>然后进入hexo-blog文件夹,比如我的在D盘的hexo目录下</p>
<p><code>cd D:\hexo\hexo-blog</code></p>
<p><img src="https://s1.ax1x.com/2023/04/30/p93O7Hx.png" alt="p93O7Hx.png" loading="lazy"></p>
<p>将网站初始化</p>
<p><code>npm install</code></p>
<p>使用<code>hexo g</code>来生成静态资源，生成的资源在public下，生成静态资源之前可以先清除缓存<code>hexo clean</code></p>
<p>用<code>hexo s</code>来开启服务器端</p>
<p><img src="https://s1.ax1x.com/2023/04/30/p93OqUK.png" alt="p93OqUK.png" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/04/30/p93OouR.png" alt="p93OouR.png" loading="lazy"></p>
<p>启动之后可以用ctrl加鼠标左键点击<code>http://localhost:4000/</code>来在本地查看网页</p>
<p>至于为什么你们的网站和我的不一样，因为我更改了主题，关于主题你们可以自行百度，毕竟每个主题的配置文档都不一样</p>
<p>至此hexo本地搭建就完成了</p>
<hr>
<h5 id="关于怎么部署"><a class="header-anchor" href="#关于怎么部署">¶</a>关于怎么部署</h5>
<p>云服务器的部署就直接将生成的静态文件全部上传到云服务器上就行了（<s>git弄不会</s>）</p>
<blockquote>
<p>Time：2023.9.11</p>
<p>也可以看看下面这篇博客:</p>
<p><a href="http://t.csdn.cn/QSZ5G">blog</a></p>
<p>至于怎么指定 git push 时登录的端口，将 config.yml 文件的 deploy 里的 repo 改为以下格式：</p>
<blockquote>
<p>ssh://&lt;你要登录的用户名&gt;@&lt;你的服务器ip&gt;:&lt;你要使用的 SSH 端口号&gt;/home/&lt;你要登录的用户目录&gt;/&lt;远端 git 仓库&gt;</p>
</blockquote>
<p>例如：</p>
<blockquote>
<p>ssh://git@xxxxxx:2000/home/git/blog.git</p>
</blockquote>
</blockquote>
<p>github pages的部署你要先创建一个仓库，然后再设置里面开启pages功能，开启需要一点时间，可以再操作种查看进度，具体的直接百度吧</p>
<hr>
<h5 id="SSL"><a class="header-anchor" href="#SSL">¶</a>SSL</h5>
<p>本章重点来了，首先是ssl是什么，以及它和https的关系</p>
<ul>
<li>
<p>它是一个安全套接层协议(Secure Sockets Layer)，用来在服务器和浏览器之间进行安全的数据传输和身份认证</p>
</li>
<li>
<p>https其实就是使用了ssl的http协议，至于为什么使用https而不使用http，就是因为http是使用明文传输数据的，这种方式极其容易被第三方截获和修改，而且以为它是明文的原因，第三方攻击者可以直接读懂其中的信息（比如某校的校园网程序，就是通过http来传输的，我可以直接通过抓包来获取它加密后的密码，如果它改用https，那我宿舍就要为网络发愁咯）</p>
</li>
</ul>
<p>既然介绍完ssl，那现在说说怎么获取吧，关于ssl的获取大致分为两种:</p>
<ul>
<li>
<p>直接使用你的钞能力买买买</p>
</li>
<li>
<p>去找免费的用( <em><s>白嫖</s></em> )</p>
</li>
</ul>
<p>像我这种穷逼当然选择第二种啦</p>
<p>本站使用的就是阿里云的免费ssl证书，你也可以使用别的平台的免费证书，比如腾讯云，华为云，百度云等</p>
<p>关于怎么获取</p>
<ul>
<li>首先你要有一个阿里云的账号，登录之后搜索ssl证书，之后按照截图点击购买免费证书</li>
</ul>
<p><img src="https://s1.ax1x.com/2023/04/30/p93OvgH.png" alt="p93OvgH.png" loading="lazy"></p>
<p>阿里的ssl免费证书每年都能购买(好像吧)，一次能买20张，想多买就要给钱钱咯</p>
<p>使用的话也挺简单的，如果你是阿里云的话可以直接部署，至于怎么部署就需要你慢慢研究啦</p>
<p>我是直接下载的证书来进行部署的，可以下载的类型挺多的</p>
<p><img src="https://s1.ax1x.com/2023/04/30/p93OTD1.png" alt="p93OTD1.png" loading="lazy"></p>
<p>下载好之后是一个zip的压缩包，里面有key和pem为后缀的文件(不同类型有所差异)</p>
<p>可以在宝塔面板里部署下载的证书（其实就是把对应文件里的内容复制过去）</p>
<p><img src="https://s1.ax1x.com/2023/04/30/p93ObE6.png" alt="p93ObE6.png" loading="lazy"></p>
<p>然后保存就可以了</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaFx使用Maven打包及运行</title>
    <url>/2023/05/02/javafx%E4%BD%BF%E7%94%A8maven%E6%89%93%E5%8C%85%E5%8F%8A%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h4 id="javafx使用maven打包依赖及运行"><a class="header-anchor" href="#javafx使用maven打包依赖及运行">¶</a>javafx使用maven打包依赖及运行</h4>
<p>1.先照图打包<br>
<img src="https://s1.ax1x.com/2023/04/07/ppTPAZ6.png" alt="1" loading="lazy"><br>
2.在target下会生成app文件夹和压缩包，进入app/bin/目录，里面有app.bat批处理文件，双击即可运行<br>
3.可以在app目录下写一个脚本文件来运行app.bat，以便隐藏cmd命令窗口<br>
<img src="https://s1.ax1x.com/2023/04/07/ppTP6FU.png" alt="3" loading="lazy"><br>
4.脚本代码<br>
<img src="https://s1.ax1x.com/2023/04/07/ppTP5ex.png" alt="4" loading="lazy"></p>
<figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> ws=WScript.<span class="built_in">CreateObject</span>(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">ws.Run <span class="string">&quot;.\bin\app.bat&quot;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>javafx</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven的使用</title>
    <url>/2023/07/08/maven%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>maven的项目结构</p>
<p><img src="https://s1.ax1x.com/2023/07/08/pCgiQts.png" alt="pCgiQts.png" loading="lazy"></p>
<ul>
<li>main	--项目的主要代码和资源
<ul>
<li>java	--项目的源代码</li>
<li>resources	--项目的资源</li>
</ul>
</li>
<li>test	--测试项目代码，目录相当于JUnit的测试代码的目录
<ul>
<li>java	--所有的单元测试.java文件，JUnit测试类等</li>
<li>resources	--项目测试的资源，spring，hibernate的配置文件</li>
</ul>
</li>
<li>target	--项目输出位置，maven编译后的类文件及打包文件会在此目录</li>
<li>pom.xml	--maven的配置文件</li>
</ul>
<h4 id="pom基础标签"><a class="header-anchor" href="#pom基础标签">¶</a>pom基础标签</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  <span class="comment">&lt;!-- pom版本 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>fun.zero.li<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 域名（项目组的唯一标识） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MavenWSM<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="comment">&lt;!-- 项目的唯一id/模块名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 项目当前版本 SNAPSHOT(快速开发) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- groupId  artifactId  version:也决定了项目在打包/发布文件的样式/地址：本地仓库下/fun/zero/MavenWSM/1.0-SNAPSHOT/MavenWSM-1.0-SNAPSHOT.jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>WSM<span class="tag">&lt;/<span class="name">name</span>&gt;</span>    <span class="comment">&lt;!-- 项目别名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="comment">&lt;!-- 项目打包产生的工件类型 有jar、war、ear、pom --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Jar: 一般公司自己制作，方便开发调用的组件Jar...     war: 项目打包成war 可以部署至服务器中运行...的格式;  这里不是web工程所以不需要war jar即可~ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="comment">&lt;!-- 给pom定义的一些常量 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定项目使用的jdk版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 提供的依赖下载坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 每个 dependency 都是一个jar坐标 1.先从本地找 -&gt; 2.去私服找 -&gt; 3.到中央仓库下载 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!-- Jar包使用的范围: 默认使用范围是compile,则测试代码和主代码都可以使用该代码 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- &lt;scope&gt;system&lt;/scope&gt;               &lt;systemPath&gt; 引入Jar资源路径... &lt;/systemPath&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="scopy标签"><a class="header-anchor" href="#scopy标签">¶</a>scopy标签</h5>
<table>
<thead>
<tr>
<th style="text-align:center">依赖范围</th>
<th style="text-align:center">对于编译class path有效</th>
<th style="text-align:center">对于测试class path有效</th>
<th style="text-align:center">对于运行class path有效</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">compile</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">spring-core</td>
</tr>
<tr>
<td style="text-align:center">test</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Junit</td>
</tr>
<tr>
<td style="text-align:center">provided</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">-</td>
<td style="text-align:center">servlet-api</td>
</tr>
<tr>
<td style="text-align:center">runtime</td>
<td style="text-align:center">-</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">JDBC驱动</td>
</tr>
<tr>
<td style="text-align:center">system</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">-</td>
<td style="text-align:center">本地的，maven仓库之外的类库</td>
</tr>
</tbody>
</table>
<p>添加依赖时需要指定其依赖范围</p>
<ul>
<li>compile
<ul>
<li>编译范围, 默认范围值，依赖会用在编译、测试、运行, 由于运行时需要所以编译范围的依赖会被打包。</li>
</ul>
</li>
<li>test
<ul>
<li>编译范围,在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。比如：junit。</li>
</ul>
</li>
<li>provided
<ul>
<li>编译范围, provided 依赖在编译和测试时需要，在运行时不需要，比如：servlet api 运行时被 tomcat 容器提供。(冲突反而会报错！)</li>
</ul>
</li>
<li>runtime
<ul>
<li>编译范围,依赖在运行和测试系统的时候需要，但在编译的时候不需要。 比如：jdbc驱动包。</li>
</ul>
</li>
<li>system
<ul>
<li>编译范围, system 范围依赖与 provided 类似, 使用本地之外的路径的Jar 需要指定 systemPath 磁盘路径(不推荐！)</li>
</ul>
</li>
</ul>
<h4 id="使用maven一键构建"><a class="header-anchor" href="#使用maven一键构建">¶</a>使用maven一键构建</h4>
<p><img src="https://s1.ax1x.com/2023/07/08/pCgBz7V.png" alt="pCgBz7V.png" loading="lazy"></p>
<blockquote>
<p>在cmd终端中输入mvn -v查看maven版本及是否安装正确</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/07/08/pCg3QqH.png" alt="pCg3QqH.png" loading="lazy">]</p>
<blockquote>
<p>使用 mvn compile 将项目编译为class文件并输出到target目录</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/07/08/pCg3zTA.png" alt="pCg3zTA.png" loading="lazy"></p>
<blockquote>
<p>使用 mvn clean 清理 target 目录,整个目录一起删掉</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/07/08/pCg8Fl8.png" alt="pCg8Fl8.png" loading="lazy"></p>
<blockquote>
<p>使用mvn test 执行src/test/java目录下的单元测试类</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/07/08/pCg8llT.png" alt="pCg8llT.png" loading="lazy"></p>
<blockquote>
<p>使用 mvn package 将java工程打包为jar包,将web工程打包为war包</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/07/08/pCg82tI.png" alt="pCg82tI.png" loading="lazy"></p>
<blockquote>
<p>使用 mvn install 将项目打包并发布到本地仓库，本步骤包含 package 和 test</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/07/08/pCgYGnS.png" alt="pCgYGnS.png" loading="lazy"></p>
<blockquote>
<p>使用 mvn deploy 也可以将项目打包，并发布到本地仓库和私服中，包含 package、test及 install</p>
</blockquote>
<blockquote>
<p>使用 mvn clean test 会先清理再 test 测试</p>
</blockquote>
<blockquote>
<p>使用 IDEA 也可以直接双击</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2023/07/08/pCgY4c6.png" alt="pCgY4c6.png" loading="lazy"></p>
<h4 id="使用maven进行模块开发"><a class="header-anchor" href="#使用maven进行模块开发">¶</a>使用maven进行模块开发</h4>
<ol>
<li>
<p>先将自己写的类用 maven 打包为 jar 并发布到本地仓库 ( 建议将本地仓库的存储位置改一下，具体度娘 )</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=&#x27;xxx.jar&#x27; -DgroupId=&#x27;xxx.xxx.xxx&#x27; -DartifactId=xxx -Dversion=&#x27;xxx.xxx.xxx&#x27; -Dpackaging=jar</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>-Dfile</code>是<code>jar</code>包的路径，<code>-DgroupID</code>是你在<code>pom.xml</code>中设置的组名，<code>-DartifactID</code>是你在<code>pom.xml</code>中设置的项目名，<code>-Dversion</code>是版本</p>
<p>注意：一定要将带点的加上单引号，否则报错</p>
</li>
</ol>
<p><img src="https://s1.ax1x.com/2023/07/08/pCgBQLq.png" alt="pCgBQLq.png" loading="lazy"></p>
<ol start="2">
<li>
<p>然后将依赖引入即可</p>
<p><img src="https://s1.ax1x.com/2023/07/08/pCgB3wV.png" alt="pCgB3wV.png" loading="lazy"></p>
</li>
</ol>
<hr>
<p>本教程参考的一些大佬的文章</p>
<p><a href="http://t.csdn.cn/hXE9V">http://t.csdn.cn/hXE9V</a></p>
<p><a href="http://t.csdn.cn/81Im6">http://t.csdn.cn/81Im6</a></p>
<p><a href="http://t.csdn.cn/E4eN8">http://t.csdn.cn/E4eN8</a></p>
<p><a href="https://www.runoob.com/maven/maven-tutorial.html">Maven 教程 | 菜鸟教程 (runoob.com)</a></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本笔记-1</title>
    <url>/2023/12/15/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h3 id="Shell命令解释器"><a class="header-anchor" href="#Shell命令解释器">¶</a>Shell命令解释器</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure>
<p>shell 的命令解释器用于执行 shell 命令或 shell 脚本文件，Centos 下有四种解释器，一般用默认的 /bin/bash 即可</p>
<h3 id="执行Shell脚本"><a class="header-anchor" href="#执行Shell脚本">¶</a>执行Shell脚本</h3>
<p>要执行 shell 脚本有两种方法：</p>
<ol>
<li>将要执行的 <code>.sh</code> 脚本通过 <code>chmod</code> 给予可执行权限，然后执行</li>
<li>不赋予可执行权限，通过 <code>bash xxx.sh</code> 或 <code>sh xxx.sh</code> 来执行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x ./hello.sh    # 方法一</span><br><span class="line"></span><br><span class="line">./hello.sh    # 方法二</span><br></pre></td></tr></table></figure>
<p>使用 <code>.sh</code> 为后缀只是为了方便区分，对实际运行脚本没有任何影响</p>
<h4 id="Shell变量"><a class="header-anchor" href="#Shell变量">¶</a>Shell变量</h4>
<p>shell 脚本定义变量除了等号两边不能加空格，其他和别的编程语言大差不差（值得一提的是，变量名不支持中文命名，其他大部分编程语言是支持的）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">name=&quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<h4 id="变量类型"><a class="header-anchor" href="#变量类型">¶</a>变量类型</h4>
<p>在运行 shell 时，会同时存在三种变量类型：</p>
<ol>
<li>局部变量：局部变量在脚本或命令中被定义，只能由当前对象使用，无法被其他 shell 启动的对象访问</li>
<li>环境变量：环境变量是所有的脚本或程序都能访问的，某些程序或脚本需要环境变量来维持运行，必要时也可以由 shell 脚本自己定义环境变量</li>
<li>shell 变量：shell 变量是由 shell 程序设置的特殊变量，shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行</li>
</ol>
<h4 id="使用变量"><a class="header-anchor" href="#使用变量">¶</a>使用变量</h4>
<p>要使用定义过的变量，只需在变量名前加美元符号，最好在变量名外加花括号以区分边界</p>
<p><img src="https://s1.ax1x.com/2023/09/09/pP6gZdO.png" alt="shell1" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/09/09/pP6gVeK.png" alt="shell2" loading="lazy"></p>
<h4 id="只读变量"><a class="header-anchor" href="#只读变量">¶</a>只读变量</h4>
<p>使用 readonly 可以将变量定义为只读变量，只读变量不能被改变</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readonly name</span><br></pre></td></tr></table></figure>
<h4 id="删除变量"><a class="header-anchor" href="#删除变量">¶</a>删除变量</h4>
<p>使用 unset 删除变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset name</span><br></pre></td></tr></table></figure>
<h3 id="Shell-传递参数"><a class="header-anchor" href="#Shell-传递参数">¶</a>Shell 传递参数</h3>
<p>有一些特殊变量在 shell 脚本中有特殊含义，如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数处理</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$#</code></td>
<td style="text-align:center">传递到脚本的参数个数</td>
</tr>
<tr>
<td style="text-align:center"><code>$*</code></td>
<td style="text-align:center">以一个单字符串的形式输出所有向脚本输入的参数</td>
</tr>
<tr>
<td style="text-align:center"><code>$$</code></td>
<td style="text-align:center">脚本运行的当前进程 <code>ID</code> 号</td>
</tr>
<tr>
<td style="text-align:center"><code>$!</code></td>
<td style="text-align:center">后台运行的最后一个进程的<code>ID</code>号</td>
</tr>
<tr>
<td style="text-align:center"><code>$@</code></td>
<td style="text-align:center">与<code>$&#123;*&#125;</code>效果相同，但是加引号时会返回以引号括起来的每个参数，与<code>$&#123;*&#125;</code>的区别是<code>$&#123;*&#125;</code>将所有参数当一个字符串处理，而<code>$&#123;@&#125;</code>则是分别处理每个参数</td>
</tr>
<tr>
<td style="text-align:center"><code>$-</code></td>
<td style="text-align:center">显示 Shell 使用的当前选项，与 <code>set</code> 命令功能相同</td>
</tr>
<tr>
<td style="text-align:center"><code>$?</code></td>
<td style="text-align:center">显示最后命令的退出状态。<code>0</code> 表示没有错误，其他任何值都表明有错误</td>
</tr>
<tr>
<td style="text-align:center"><code>$0</code></td>
<td style="text-align:center">表示脚本的名称</td>
</tr>
<tr>
<td style="text-align:center"><code>$1</code></td>
<td style="text-align:center">表示脚本的参数，可以有多个，用<code>$&#123;1&#125;</code> 、<code>$&#123;2&#125;</code> …表示</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;有$&#123;#&#125;个参数&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;参数:$&#123;*&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;进程ID:$&#123;$&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;最后一个进程ID:$&#123;!&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Shell选项:$&#123;-&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;脚本name:$&#123;0&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;$&#123;1&#125; + $&#123;2&#125; = &quot;`expr $&#123;1&#125; + $&#123;2&#125;`</span><br><span class="line"></span><br><span class="line">echo $&#123;?&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入：</p>
<blockquote>
<p>bash ./test.sh 10 20</p>
</blockquote>
<p>输出结果：</p>
<blockquote>
<p>有2个参数<br>
参数:10 20<br>
进程ID:71819<br>
最后一个进程ID:<br>
Shell选项:hB<br>
脚本name:./test.sh<br>
10 + 20 = 30<br>
0</p>
</blockquote>
<h3 id="Shell字符串"><a class="header-anchor" href="#Shell字符串">¶</a>Shell字符串</h3>
<p>shell 的字符串可以加双引号、单引号，也可以不加引号</p>
<h4 id="单引号"><a class="header-anchor" href="#单引号">¶</a>单引号</h4>
<ul>
<li>
<p>加单引号的字符串中的变量是无效的，可以使用单引号将变量引用起来达到拼接字符串的目的</p>
</li>
<li>
<p>单引号字符串中不能出现单独的单引号，转义后也不行，只能成对出现</p>
</li>
</ul>
<h4 id="双引号"><a class="header-anchor" href="#双引号">¶</a>双引号</h4>
<ul>
<li>双引号中可以有变量</li>
<li>双引号中可以出现转义字符</li>
</ul>
<h4 id="拼接字符串"><a class="header-anchor" href="#拼接字符串">¶</a>拼接字符串</h4>
<p>使用双引号拼接字符串：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">name=&quot;QSky&quot;</span><br><span class="line">echo &quot;Hello! $&#123;name&#125;&quot;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Hello! QSky</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/09/pP6RMrt.png" alt="shell3" loading="lazy"></p>
<p>输出结果：</p>
<blockquote>
<p>string hello world</p>
<p>string ${name}</p>
<p>string hello world</p>
<p>“string” hello world</p>
</blockquote>
<h4 id="获取字符串的长度"><a class="header-anchor" href="#获取字符串的长度">¶</a>获取字符串的长度</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str=&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">echo $&#123;#str&#125;    # $&#123;#str&#125; 等价于 $&#123;#str[0]&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>11</p>
</blockquote>
<h4 id="提取子字符串"><a class="header-anchor" href="#提取子字符串">¶</a>提取子字符串</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str=&quot;hello world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">语法：字符串变量名:要提取的子串的开始位置:要提取的子串的结束位置</span></span><br><span class="line">echo $&#123;str:6:8&#125;    # 第一个字符 &#x27;h&#x27; 索引为0</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>world</p>
</blockquote>
<h4 id="查找字符串"><a class="header-anchor" href="#查找字符串">¶</a>查找字符串</h4>
<p>查找字符 <code>i</code> 或 <code>o</code> 的位置，哪个先出现就计算哪个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str=&quot;hello world&quot;</span><br><span class="line">echo `expr index &quot;$str&quot; or`</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>5</p>
</blockquote>
<h3 id="Shell数组"><a class="header-anchor" href="#Shell数组">¶</a>Shell数组</h3>
<p>和大多数编程语言一样，shell 脚本也有数组，但与其他编程语言不同的是，shell 不支持多维数组，不过 shell 的数组并没有长度限制，并且可以使用不连续的下标，下标范围也没有限制</p>
<h4 id="定义-shell-数组"><a class="header-anchor" href="#定义-shell-数组">¶</a>定义 shell 数组</h4>
<p>数组用小括号来表示，用空格区分值</p>
<p>格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line"></span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array_name=(</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>也能单独定义数组的单个元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line"></span><br><span class="line">array_name[1]=value1</span><br><span class="line"></span><br><span class="line">array_name[5]=value5</span><br></pre></td></tr></table></figure>
<h4 id="读取数组"><a class="header-anchor" href="#读取数组">¶</a>读取数组</h4>
<p>和其他编程语言一样，shell 同样是通过数组名加下标来读取元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;数组名[下标]&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>@</code> 或 <code>*</code> 读取数组的全部元素：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">  </span><br><span class="line">str=(</span><br><span class="line">&#x27;string &#x27;$&#123;name&#125;&#x27;&#x27;</span><br><span class="line">&#x27;string $&#123;name&#125;&#x27;</span><br><span class="line">&quot;string $&#123;name&#125;&quot;</span><br><span class="line">&quot;\&quot;string\&quot; $&#123;name&#125;&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">echo $&#123;str[@]&#125; # 和 echo $&#123;str[*]&#125; 效果相同</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<h6 id="为了便于阅读，我给输出结果分段处理了"><a class="header-anchor" href="#为了便于阅读，我给输出结果分段处理了">¶</a>为了便于阅读，我给输出结果分段处理了</h6>
<p>string hello world</p>
<p>string ${name}</p>
<p>string hello world</p>
<p>“string” hello world</p>
</blockquote>
<h4 id="获取数组的长度"><a class="header-anchor" href="#获取数组的长度">¶</a>获取数组的长度</h4>
<p>获取数组长度的方法与获取字符串长度的方法相似</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">length_1=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line"></span><br><span class="line">length_2=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取单个数组元素的长度</span></span><br><span class="line"></span><br><span class="line">length_3=$&#123;#array_name[2]&#125;</span><br><span class="line"></span><br><span class="line">echo $&#123;length_1&#125; $&#123;length_2&#125; $&#123;length_3&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>4 4 6</p>
<p>注：6 为第二个下标所表示的元素的长度</p>
</blockquote>
<h4 id="关联数组"><a class="header-anchor" href="#关联数组">¶</a>关联数组</h4>
<p>bash 脚本支持关联数组，可以使用任意的字符串或者整数来作为下标来访问数组。</p>
<p>关联数组的键是唯一的，有点类似于其他编程语言的键值对。</p>
<p>语法：</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">declare -A array-name=([&quot;key_1&quot;]=&quot;value_1&quot;</span><br><span class="line">[&quot;key_2&quot;]=&quot;value_2&quot;</span><br><span class="line">[&quot;key_3&quot;]=&quot;value_3&quot;</span><br><span class="line">[&quot;key_4&quot;]=&quot;value_4&quot;</span><br><span class="line">...</span><br><span class="line">[&quot;key_n&quot;]=&quot;value_n&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用 <code>declare</code> 命令来声明，<code>-A</code> 选项就是用于声明一个关联数组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">declare -A site=([&quot;name&quot;]=&quot;QSky&quot;</span><br><span class="line">[&quot;url&quot;]=&quot;zero-li.fun&quot;</span><br><span class="line">)</span><br><span class="line">echo $&#123;site[@]&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>zero-li.fun QSky</p>
</blockquote>
<p>同样可以先声明再赋值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">declare -A site</span><br><span class="line">site[&quot;zero&quot;]=&quot;zero-li.fun&quot;</span><br><span class="line">echo $&#123;site[&quot;zero&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>zero-li.fun</p>
</blockquote>
<h3 id="Shell-注释"><a class="header-anchor" href="#Shell-注释">¶</a>Shell 注释</h3>
<p>在 shell 脚本中，以 <code>#</code> 开头的就是注释。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这是一句注释</span></span><br><span class="line">echo 注释的内容并不会被执行</span><br></pre></td></tr></table></figure>
<h4 id="多行注释"><a class="header-anchor" href="#多行注释">¶</a>多行注释</h4>
<p>可以使用 <code>:</code> 命令，并用单引号 <code>'</code> 将多行内容括起来。</p>
<p>语法：<code>:</code> + <code> </code> (空格) + <code>'</code> (单引号)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">: &#x27;</span><br><span class="line">这是多段注释</span><br><span class="line">可以有多行内容</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>
<p>shell常用命令及关键字：</p>
<p><code>readonly</code>：将变量定义为只读，无法更改其值</p>
<p><code>unset</code>：删除变量，无法删除只读变量</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本笔记 - 2</title>
    <url>/2023/11/27/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h3 id="Shell"><a class="header-anchor" href="#Shell">¶</a>Shell</h3>
<p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现。</p>
<h4 id="expr"><a class="header-anchor" href="#expr">¶</a><code>expr</code></h4>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作，一般用于整数值，也可用于字符串。</p>
<p>使用 expr 时，一定要将 expr 表达式用<b>反引号</b>括起来或使用<code>$()</code>将其括起来。</p>
<p>语法：</p>
<blockquote>
<p><code>$(expr 表达式)</code></p>
</blockquote>
<h4 id="字符串操作"><a class="header-anchor" href="#字符串操作">¶</a>字符串操作</h4>
<ol>
<li>计算字符串的长度
<ul>
<li><code>length</code></li>
<li>语法：<code>expr length string_name</code></li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">echo $(expr length &quot;$&#123;str&#125;&quot;)</span><br></pre></td></tr></table></figure>
<p>输出说明：</p>
<blockquote>
<p>11</p>
</blockquote>
<ol start="2">
<li>截取字符串子串
<ul>
<li><code>substr</code></li>
<li>语法：<code>expr substr string_name start_num end_num</code></li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">echo $(expr substr &quot;$&#123;str&#125;&quot; 1 5)</span><br></pre></td></tr></table></figure>
<p>输出说明：</p>
<blockquote>
<p>hello</p>
</blockquote>
<ol start="3">
<li>截取第一个字符串出现的位置
<ul>
<li><code>index</code></li>
<li>语法：<code>expr index string_name substrings_name</code></li>
</ul>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">str=&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">echo $(expr index &quot;$&#123;str&#125;&quot; e)</span><br></pre></td></tr></table></figure>
<h4 id="运算符"><a class="header-anchor" href="#运算符">¶</a>运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">加法运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center">减法运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">乘法运算符，在使用 <code>*</code> 运算符时，需要使用反斜杠(<code>\</code>)进行转义</td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center">除法运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center">求余运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">赋值运算符</td>
</tr>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center">相等运算符，用于比较两个数字</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">不相等运算符，用于比较两个数字</td>
</tr>
</tbody>
</table>
<h5 id="算数运算符"><a class="header-anchor" href="#算数运算符">¶</a>算数运算符</h5>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">减法</span></span><br><span class="line">echo  &quot;$&#123;1&#125; - $&#123;2&#125; = &quot; $(expr $&#123;1&#125; - $&#123;2&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加法</span></span><br><span class="line">echo &quot;$&#123;1&#125; + $&#123;2&#125; = &quot; $(expr $&#123;1&#125; + $&#123;2&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">乘法</span></span><br><span class="line">echo &quot;$&#123;1&#125; * $&#123;2&#125; = &quot; $(expr $&#123;1&#125; \* $&#123;2&#125;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">除法</span></span><br><span class="line">echo &quot;$&#123;1&#125; / $&#123;2&#125; = &quot; $(expr $&#123;1&#125; / $&#123;2&#125;) </span><br></pre></td></tr></table></figure>
<p>输入：</p>
<blockquote>
<p>bash ./demo.sh 20 10</p>
</blockquote>
<p>输出结果：</p>
<blockquote>
<p>20 - 10 = 10</p>
<p>20 + 10 = 30</p>
<p>20 * 10 = 200</p>
<p>20 / 10 = 2</p>
</blockquote>
<h5 id="条件运算符"><a class="header-anchor" href="#条件运算符">¶</a>条件运算符</h5>
<p>以下运算符中，括号内的和括号外的作用相同</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==(-eq)</code></td>
<td style="text-align:center">检测两个数是否相等，相等返回 <code>true</code></td>
</tr>
<tr>
<td style="text-align:center"><code>!=(-ne)</code></td>
<td style="text-align:center">检测两个数是否不相等，不相等返回<code>true</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;(-gt)</code></td>
<td style="text-align:center">检测左边的数是否大于右边的数</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;(-lt)</code></td>
<td style="text-align:center">检测左边的数是否小于右边的数</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=(-ge)</code></td>
<td style="text-align:center">检测左边的数是否大于等于右边的数</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=(-le)</code></td>
<td style="text-align:center">检测左边的数是否小于等于右边的数</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;等于:&quot;</span><br><span class="line">if [[ $&#123;1&#125; == $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 等于 $&#123;2&#125;\n&quot;</span><br><span class="line">else</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 不等于 $&#123;2&#125;\n&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;不等于:&quot;</span><br><span class="line">if [[ $&#123;1&#125; != $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 不等于 $&#123;2&#125;\n&quot;</span><br><span class="line">else</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 等于 $&#123;2&#125;\n&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;大于:&quot;</span><br><span class="line">if [[ $&#123;1&#125; &gt; $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 大于 $&#123;2&#125;\n&quot;</span><br><span class="line">else</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 小于 $&#123;2&#125;\n&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;小于:&quot;</span><br><span class="line">if [[ $&#123;1&#125; &lt; $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 小于 $&#123;2&#125;\n&quot;</span><br><span class="line">else</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 大于 $&#123;2&#125;\n&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;大于等于:&quot;</span><br><span class="line">if (( $&#123;1&#125; &gt;= $&#123;2&#125; ))</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 大于等于 $&#123;2&#125;\n&quot;</span><br><span class="line">else</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 小于等于 $&#123;2&#125;\n&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;小于等于:&quot;</span><br><span class="line">if (( $&#123;1&#125; &lt;= $&#123;2&#125; ))</span><br><span class="line">then</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 小于等于 $&#123;2&#125;\n&quot;</span><br><span class="line">else</span><br><span class="line">        echo -e &quot;$&#123;1&#125; 大于等于 $&#123;2&#125;\n&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>等于:<br>
10 不等于 15</p>
<p>不等于:<br>
10 不等于 15</p>
<p>大于:<br>
10 小于 15</p>
<p>小于:<br>
10 小于 15</p>
<p>大于等于:<br>
10 小于等于 15</p>
<p>小于等于:<br>
10 小于等于 15</p>
</blockquote>
<h5 id="布尔运算符"><a class="header-anchor" href="#布尔运算符">¶</a>布尔运算符</h5>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">非运算，对表达式结果取反</td>
</tr>
<tr>
<td style="text-align:center">||<code>(-o)</code></td>
<td style="text-align:center">或运算，表达式结果有一个为 <code>true</code>，那么整体结果都为 <code>true</code></td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;(-a)</code></td>
<td style="text-align:center">与运算，表达式结果都为 <code>true</code>才返回 <code>true</code></td>
</tr>
</tbody>
</table>
<p>注意：在 <code>[[]]</code> 中不能使用 <code>-o</code> 和 <code>-a</code> 运算符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [[ $&#123;1&#125; &gt; $&#123;2&#125; || $&#123;1&#125; &lt; $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;1&#125; &gt; $&#123;2&#125; &amp;&amp; $&#123;1&#125; &lt; $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ ! $&#123;1&#125; == $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>输入：./demo.sh 10 15</p>
<p>输出结果:</p>
<blockquote>
<p>true</p>
<p>false</p>
<p>true</p>
</blockquote>
<h5 id="字符串运算符"><a class="header-anchor" href="#字符串运算符">¶</a>字符串运算符</h5>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">检测两个字符串是否相等</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">检测两个字符串是否不相等</td>
</tr>
<tr>
<td style="text-align:center"><code>-z</code></td>
<td style="text-align:center">检测字符串的长度是否为<code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-n</code></td>
<td style="text-align:center">检测字符串的长度是否不为<code>0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:center">检测字符串是否不为空</td>
</tr>
</tbody>
</table>
<p>注意：在使用<code>-n</code>运算符时，应该给要判断的字符串加上 <code>&quot;&quot;</code> 号，否则检测的结果永远是 <code>true</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [[ $&#123;1&#125; = $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;1&#125; != $&#123;2&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -z $&#123;1&#125; ]]</span><br><span class="line">then</span><br><span class="line">        echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ -n &quot;$&#123;1&#125;&quot; ]]</span><br><span class="line">then</span><br><span class="line">        echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $&#123;1&#125; ]]</span><br><span class="line">then</span><br><span class="line">	echo &quot;true&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>输入：./demo.sh hello world</p>
<p>输出结果：</p>
<blockquote>
<p>false</p>
<p>true</p>
<p>false</p>
<p>true</p>
<p>true</p>
</blockquote>
<h5 id="文件测试运算符"><a class="header-anchor" href="#文件测试运算符">¶</a>文件测试运算符</h5>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-b file</code></td>
<td style="text-align:center">检测文件是否是块设备文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-c file</code></td>
<td style="text-align:center">检测文件是否是字符设备文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-d file</code></td>
<td style="text-align:center">检测文件是否是目录</td>
</tr>
<tr>
<td style="text-align:center"><code>-f file</code></td>
<td style="text-align:center">检测文件是否是普通文件</td>
</tr>
<tr>
<td style="text-align:center"><code>-g file</code></td>
<td style="text-align:center">检测文件是否设置了 <code>SGID</code> 位</td>
</tr>
<tr>
<td style="text-align:center"><code>-k file</code></td>
<td style="text-align:center">检测文件是否设置了粘着位<code>(Sticky Bit)</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-p file</code></td>
<td style="text-align:center">检测文件是否是有名管道</td>
</tr>
<tr>
<td style="text-align:center"><code>-u file</code></td>
<td style="text-align:center">检测文件是否设置了 <code>SUID</code> 位</td>
</tr>
<tr>
<td style="text-align:center"><code>-r file</code></td>
<td style="text-align:center">检测文件是否可读</td>
</tr>
<tr>
<td style="text-align:center"><code>-w file</code></td>
<td style="text-align:center">检测文件是否可写</td>
</tr>
<tr>
<td style="text-align:center"><code>-x file</code></td>
<td style="text-align:center">检测文件是否可执行</td>
</tr>
<tr>
<td style="text-align:center"><code>-s file</code></td>
<td style="text-align:center">检测文件是否为空（文件大小是否大于<code>0</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>-e file</code></td>
<td style="text-align:center">检测文件（包括目录）是否存在</td>
</tr>
</tbody>
</table>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>windows之重装系统</title>
    <url>/2023/06/17/windows%E4%B9%8B%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h5 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h5>
<p>之所以写这篇文章，是因为我朋友电脑出问题，把系统重装了一下，其实我在很早之前就写过一篇重装系统的教程，但是是放在了石墨文档上面，那时候还没有自己的个人博客呢（笑）</p>
<h5 id="正文"><a class="header-anchor" href="#正文">¶</a>正文</h5>
<p>此文章不会教你怎么装系统，但是我会把我以前写的那篇教程放出来，需要的可以自行下载查看</p>
<blockquote>
<p><a href="https://8.222.153.91:39811/down/iS8YyJSjuWpd.docx">下载链接:</a> 提取码:YunYi</p>
</blockquote>
<p>至于怎么获取Windows的系统镜像，你可以去阿里的国内镜像点去找，或者清华的镜像点也行。我并不会提供镜像的下载，毕竟一个镜像就有好几个g，我这小水管带宽可供不起.</p>
<hr>
<p>顺便吐槽一下，我朋友那电脑，真是大毛病没有，小毛病不断，不是网卡驱动掉了，就是电脑蓝屏，属实买的血亏。</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>计算机知识</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>电脑技术</tag>
      </tags>
  </entry>
  <entry>
    <title>windows重装系统重制版</title>
    <url>/2023/11/29/windows%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E9%87%8D%E5%88%B6%E7%89%88/</url>
    <content><![CDATA[<h3 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h3>
<p><strong>重要</strong>：在阅读本文章前请确保你已拥有以下技能：</p>
<ul>
<li>学会正常使用搜索引擎</li>
<li>拥有基本的动手能力</li>
<li>拥有义务教育阶段要求的知识水平</li>
</ul>
<p>如果没有以上技能，请立即停止阅读本文章并关闭浏览器。</p>
<p>如果你有以上技能，并在完整阅读本文章内容后出现疑问，请先阅读提问的智慧再向我提问，否则别问我问题，我只会忽略你。</p>
<blockquote>
<p>提问的智慧：<a href="https://ask.icodeq.com/">提问的智慧(中文版)</a></p>
</blockquote>
<hr>
<h3 id="正文"><a class="header-anchor" href="#正文">¶</a>正文</h3>
<h4 id="准备工作"><a class="header-anchor" href="#准备工作">¶</a>准备工作</h4>
<p>重装系统有很多方法，本次使用的是使用 Wepe 工具箱将 U 盘 做成pe启动盘来重装系统。</p>
<h5 id="微pe下载"><a class="header-anchor" href="#微pe下载">¶</a>微pe下载</h5>
<blockquote>
<p><a href="https://www.wepe.com.cn">官网</a></p>
</blockquote>
<p>直接去它官网下载，具体怎么把 U 盘做成系统启动盘请自行百度，网上一搜一大把教程。</p>
<h4 id="重装"><a class="header-anchor" href="#重装">¶</a>重装</h4>
<ol>
<li>
<p>先去下载你要重装系统的镜像，在哪下载请自行浏览器搜索。</p>
</li>
<li>
<p>将 U 盘插入已经下载了镜像的电脑，并将镜像移入 U 盘中的 F 盘。</p>
</li>
</ol>
<p>注意：下图的 EFI 盘是系统盘，请不要将任何文件放入其中，如果你没有，请忽略。</p>
<p><img src="https://z1.ax1x.com/2023/11/29/piDrqe0.jpg" alt="0" loading="lazy"></p>
<ol start="3">
<li>将 U 盘插入要重装系统的电脑，然后重启电脑，并在重启过程中不断的按 F2 键以进入系统 BIOS，不同的电脑进入的方法或快捷键不一样，请自行浏览器搜索你自己电脑进入的方法，本文所使用的电脑为华硕天选2。</li>
<li>进入 BIOS 后，在下图右边所示位置应该有两个盘，将下面的 UEFI 盘移动到 Windows Boot 盘的上面，有可能你的盘名字和我的不一样，但是名字应该都是差不多的。</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/29/piDDX2d.jpg" alt="1" loading="lazy"></p>
<ol start="5">
<li>重启电脑进入 wepe 桌面，点击桌面上的分区工具。</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/29/piDDHUO.jpg" alt="2" loading="lazy"></p>
<ol start="6">
<li>然后选择你要分盘的硬盘，之后选上面的快速分区。</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/29/piDDb5D.jpg" alt="3" loading="lazy"></p>
<ol start="7">
<li>将你的分区表类型改为 GPI(GUID)，一般是默认的。</li>
<li>分区数目就是你要分几个磁盘就选几个分区，一般两个磁盘就够了，在右边可以设置每个分区(磁盘)的大小，第一个硬盘一般都是 C 盘，建议将大小设置为 120 G 。</li>
<li>然后将创建新 ESP 分区勾选上，勾选不了的就将上面的保留现有的 ESP 分区取消勾选。</li>
<li>对齐分区到此扇区数的整数倍选择 4096 扇区。</li>
<li>最后点击确定。</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/29/piDDLPe.jpg" alt="4" loading="lazy"></p>
<ol start="12">
<li>回到桌面，点击 Windows安装器。</li>
<li>进入之后先选择你在 U 盘里的镜像，然后选择你要安装系统的位置，一般安装到 C 盘。</li>
<li>最后点击安装。</li>
<li>在一切完毕之后重启电脑就 ok 了。</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/29/piDDO8H.jpg" alt="5" loading="lazy"></p>
<h3 id="免责声明"><a class="header-anchor" href="#免责声明">¶</a>免责声明</h3>
<p>本文的内容仅供读者参考，不构成任何投资、法律或其他方面的建议。本文的信息和数据来自公开渠道，作者不保证其准确性和完整性。读者在阅读本文后，应自行判断其适用性和可靠性，并自行承担由此可能产生的所有风险和责任。作者对读者因阅读本文而造成的任何直接或间接的损失或损害概不负责。</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>计算机知识</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>电脑技术</tag>
      </tags>
  </entry>
  <entry>
    <title>任意版本win远程桌面使用内网穿透连接</title>
    <url>/2023/11/28/%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACwin%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h3 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h3>
<p><b>重要</b>：请不要问我为什么不能访问 GitHub 网站这种问题</p>
<p>win 系统并不能使用 ssh 来连接，但是可以使用 win 自带的远程桌面来连接。</p>
<p>但是，这时候就出现了一个问题，只有专业版的 win 系统能被远程连接，家庭版的并不行，但是不要方，GitHub 有大佬开源了 win 远程桌面的补丁，使得家庭版的 win 系统也能被远程连接。</p>
<hr>
<h3 id="下载补丁"><a class="header-anchor" href="#下载补丁">¶</a>下载补丁</h3>
<p>补丁存储库：</p>
<blockquote>
<p><a href="https://github.com/stascorp/rdpwrap/releases">Releases · stascorp/rdpwrap (github.com)</a></p>
<p>直接下载 zip 压缩包即可</p>
</blockquote>
<h3 id="运行"><a class="header-anchor" href="#运行">¶</a>运行</h3>
<ol>
<li>解压下载的补丁压缩包</li>
<li>以管理员权限运行 <code>install.bat</code>，不会运行的右键，然后点击 “以管理员身份运行” 。</li>
<li>此时打开补丁文件夹里的 <code>RDPConf.exe</code>，不出意外的话会显示如下图所示的红色字体。</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/28/piDMKUK.jpg" alt="2" loading="lazy"></p>
<ol start="4">
<li>按键盘的 <code>win + x</code> 组合键，然后选择计算机管理或按 <code>G</code> 键，依次点击 <code>服务和应用程序 -&gt; 服务</code>，然后在里面找到 <code>Remote Desktop Services</code>（如下图所示），先点击 “停止” 。</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/28/piDMM4O.jpg" alt="1" loading="lazy"></p>
<ol start="5">
<li>为了方便，我写了一个自动部署的脚本，运行 <code>run.bat</code> 即可，在弹出的 UAC 窗口点击是。</li>
</ol>
<blockquote>
<p><a href="https://wwdt.lanzout.com/iVqbr1g93b8j">点击下载脚本</a></p>
</blockquote>
<ol start="6">
<li>
<p>运行完脚本按照步骤 4 重新启动一下服务。</p>
</li>
<li>
<p>重启完服务然后打开 <code>RDPConf.exe</code>，如果全部变绿了就已经弄好了。</p>
</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/11/28/piDMuE6.jpg" alt="3" loading="lazy"></p>
<h3 id="frp-内网穿透"><a class="header-anchor" href="#frp-内网穿透">¶</a>frp 内网穿透</h3>
<p>frp 内穿我之前写过教程，这里只需要在需要内穿的客户端配置就行。</p>
<ol>
<li>先下载win系统的 frp 压缩包。</li>
</ol>
<blockquote>
<p><a href="https://github.com/fatedier/frp/releases">下载地址</a></p>
</blockquote>
<p>注意，不要下错了，下载 windows_amd64 的，arm64 是给手机处理器用的。</p>
<ol start="2">
<li>下载完之后，解压打开 frpc.toml 配置文件。</li>
</ol>
<p>照着我的配置文件写就行。</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 填你公网服务器的 ip 地址</span></span><br><span class="line"><span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填你公网服务器上的 frps 配置文件里写的端口号</span></span><br><span class="line"><span class="attr">serverPort</span> = <span class="number">7000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置了 token 的可以填一下</span></span><br><span class="line"><span class="comment"># token</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[proxies]]</span></span><br><span class="line"><span class="comment"># 你要内穿的服务名，随便填，你自己认识就行</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;desktop&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你要穿透的服务使用的协议，一般默认就行</span></span><br><span class="line"><span class="attr">type</span> = <span class="string">&quot;tcp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你要穿透的服务所在的机器的 ip ，默认就行</span></span><br><span class="line"><span class="attr">localIP</span> = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你要穿透的服务所使用的端口号</span></span><br><span class="line"><span class="attr">localPort</span> = <span class="number">3389</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你服务器监听的端口号，</span></span><br><span class="line"><span class="attr">remotePort</span> = <span class="number">6000</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>弄好之后在当前目录右键，在终端中打开，输入以下命令。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">./frpc <span class="literal">-c</span> ./frpc.toml</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>显示下面的代码就是启动好了</p>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">2023</span>/<span class="number">11</span>/<span class="number">28</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">54</span> [<span class="type">I</span>] [<span class="type">root.go</span>:<span class="number">139</span>] <span class="built_in">start</span> frpc service <span class="keyword">for</span> config file [<span class="type">.</span>\<span class="type">frpc.toml</span>]</span><br><span class="line"><span class="number">2023</span>/<span class="number">11</span>/<span class="number">28</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">56</span> [<span class="type">I</span>] [<span class="type">service.go</span>:<span class="number">299</span>] [<span class="type">c18837c64f3317f9</span>] login to server success, get run id [<span class="type">c18837c64f3317f9</span>]</span><br><span class="line"><span class="number">2023</span>/<span class="number">11</span>/<span class="number">28</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">56</span> [<span class="type">I</span>] [<span class="type">proxy_manager.go</span>:<span class="number">156</span>] [<span class="type">c18837c64f3317f9</span>] proxy added: [<span class="type">desktop</span>]</span><br><span class="line"><span class="number">2023</span>/<span class="number">11</span>/<span class="number">28</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">56</span> [<span class="type">I</span>] [<span class="type">control.go</span>:<span class="number">173</span>] [<span class="type">c18837c64f3317f9</span>] [<span class="type">desktop</span>] <span class="built_in">start</span> proxy success</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>之后让别人直接通过你服务器 ip+ 监听的端口来远程连接你电脑就行。</li>
</ol>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>frp</tag>
      </tags>
  </entry>
  <entry>
    <title>使用cAdvisor+Prometheus+Grafana监控Docker容器</title>
    <url>/2023/09/26/%E4%BD%BF%E7%94%A8cAdvisor-Prometheus-Grafana%E7%9B%91%E6%8E%A7Docker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h4 id="1-0-下载镜像"><a class="header-anchor" href="#1-0-下载镜像">¶</a>1.0 下载镜像</h4>
<ol>
<li>先使用下面的命令下载必要的镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull google/cadvisor ; docker pull prom/prometheus ; docker pull grafana/grafana</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/26/pPHGeun.png" alt="pPHGeun.png" loading="lazy"></p>
<h4 id="2-0-cAdvisor-的部署"><a class="header-anchor" href="#2-0-cAdvisor-的部署">¶</a>2.0 cAdvisor 的部署</h4>
<ol>
<li>使用下面的命令将本地的 根目录、/sys、/var/lib/docker、/dev/disk等目录以只读形式挂载到容器里，然后使用 -p 将本地端口映射到容器，使用 --privileged 给予容器特权模式，使用 --device=/dev/kmsg 将主机的 /dev/kmsg 设备文件添加到容器中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -v /:/rootfs:ro -v /var/run:/var/run:ro -v /sys:/sys:ro -v /var/lib/docker/:/var/lib/docker:ro -v /dev/disk/:/dev/disk:ro -p 25571:8080 --detach=true --name=cadvisor --privileged --device=/dev/kmsg google/cadvisor</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/26/pPHwpYq.png" alt="pPHwpYq.png" loading="lazy"></p>
<ol start="2">
<li>在浏览器输入 <code>你的ip:25571/containers/docker</code> 即可访问</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/26/pPHwilT.png" alt="pPHwilT.png" loading="lazy"></p>
<h4 id="3-0-Prometheus-的部署"><a class="header-anchor" href="#3-0-Prometheus-的部署">¶</a>3.0 Prometheus 的部署</h4>
<ol>
<li>先创建配置文件存放的目录，然后使用 vim 创建并编辑 <code>prometheus.yml</code> 配置文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/prometheus ; vim /etc/prometheus/prometheus.yml</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后在 prometheus.yml 文件中写入以下内容</li>
</ol>
<p>将 ip 地址跟端口号改为自己的就行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">global:</span><br><span class="line">  scrape_interval: 15s</span><br><span class="line">  evaluation_interval: 15s</span><br><span class="line">alerting:</span><br><span class="line"> alertmanagers:</span><br><span class="line"> - static_configs:</span><br><span class="line">   - targets:</span><br><span class="line">rule_files:</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: &#x27;prometheus&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.234.128:25572&#x27;]</span><br><span class="line">  - job_name: &#x27;cadvisor&#x27;</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [&#x27;192.168.234.128:25571&#x27;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：缩进一定要跟我的一样，错一个字符都不行，因为我容器已经运行起来了才截的图，所以你们现在应该是没有这个容器的</p>
</blockquote>
<p><img src="https://z1.ax1x.com/2023/09/26/pPHw9f0.png" alt="pPHw9f0.png" loading="lazy"></p>
<ol start="3">
<li>使用 run 将容器运行起来</li>
</ol>
<blockquote>
<p>建议先使用 docker ps -a 查看容器有没有真正运行起来，有时候会出现成功创建但是没有运行起来的情况，这种情况一般都是配置文件有问题导致的</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name=prometheus -p 25572:9090 -v /etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus --config.file=/etc/prometheus/prometheus.yml --web.enable-lifecycle</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在浏览器输入你的 ip:25572/targets 来访问</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/26/pPHwPpV.png" alt="pPHwPpV.png" loading="lazy"></p>
<h4 id="4-0-Grafana-的部署"><a class="header-anchor" href="#4-0-Grafana-的部署">¶</a>4.0 Grafana 的部署</h4>
<ol>
<li>因为之前已经把所有的镜像都已经下载了，所以直接用 run 来运行就行了，之后在浏览器中使用 你的IP:25573/login 来访问即可</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -itd --name=grafana -p 25573:3000 grafana/grafana</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHyPpR.png" alt="pPHyPpR.png" loading="lazy"></p>
<ol start="2">
<li>默认账号及密码都为 admin ，登录之后网站会强制你更新密码</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHyZ7D.png" alt="pPHyZ7D.png" loading="lazy"></p>
<ol start="3">
<li>进入管理界面之后点击 DATA SOURCES 来创建数据源</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHyV0O.png" alt="pPHyV0O.png" loading="lazy"></p>
<ol start="4">
<li>选择第一个数据源</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHyuhd.png" alt="pPHyuhd.png" loading="lazy"></p>
<ol start="5">
<li>在 HTTP 的 URL 栏填入你的 Prometheus 访问地址，然后选 Save &amp; test 保存并退出</li>
</ol>
<p>如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://192.168.234.128:25572/targets</span><br></pre></td></tr></table></figure>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHy8nf.png" alt="pPHy8nf.png" loading="lazy"></p>
<ol start="6">
<li>点击左边工具栏的 ‘+’ 号，然后点击 Import ，输入 193 ，点击后面的 Import</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHytAg.png" alt="pPHytAg.png" loading="lazy"></p>
<ol start="7">
<li>在 Prometheus 列选择数据源，之后点击 Import</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHy0cq.png" alt="pPHy0cq.png" loading="lazy"></p>
<ol start="8">
<li>之后就可以看到仪表盘显示的数据了</li>
</ol>
<p><img src="https://z1.ax1x.com/2023/09/27/pPHycEF.png" alt="pPHycEF.png" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>cAdvisor</tag>
        <tag>Prometheus</tag>
        <tag>Grafana</tag>
      </tags>
  </entry>
  <entry>
    <title>可道云桌面搭建笔记</title>
    <url>/2023/09/08/%E5%8F%AF%E9%81%93%E4%BA%91%E6%A1%8C%E9%9D%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="可道云桌面搭建"><a class="header-anchor" href="#可道云桌面搭建">¶</a>可道云桌面搭建</h4>
<ol>
<li>先创建 dockerfile-two 及 kod-two 文件夹（因为我之前搭过一遍，但是忘记截图了，所以重搭一遍，防止文件名重复所以用 -two ）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p dockerfile-two/kod-two</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/08/pP6lYIe.png" alt="pP6lYIe.png" loading="lazy"></p>
<ol start="2">
<li>使用 scp 将所必要的文件传到服务器上（请务必不要照抄我的命令）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp .\source\* root@8.222.153.91:/root/dockerfile-two/kod-two/</span><br></pre></td></tr></table></figure>
<ul>
<li>实在不会上传那就用下面的这条命令吧（复制粘贴总会吧？）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O https://zero-li.fun/资源/source.tar ; tar -xf source.tar ; mv -f source/* ./ ; rm -rf sour*</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/08/pP61SeK.png" alt="pP61SeK.png" loading="lazy"></p>
<ol start="3">
<li>使用 vim 创建 dockerfile 文件并填入以下内容：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim dockerfile</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos:centos7    # 改为你的基础镜像</span><br><span class="line"></span><br><span class="line">ADD Centos-7.repo /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line">ADD epel-7.repo /etc/yum.repos.d/</span><br><span class="line"></span><br><span class="line">RUN yum -y install nginx php-fpm php-gd php-mbstring unzip</span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;/^user/c user=nginx&#x27; /etc/php-fpm.d/www.conf</span><br><span class="line"></span><br><span class="line">RUN sed -i &#x27;/^group/c group=nginx&#x27; /etc/php-fpm.d/www.conf</span><br><span class="line"></span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">RUN mkdir /code</span><br><span class="line"></span><br><span class="line">WORKDIR /code/</span><br><span class="line"></span><br><span class="line">COPY kodexplorer4.40.zip .</span><br><span class="line"></span><br><span class="line">RUN unzip kodexplorer4.40.zip</span><br><span class="line"></span><br><span class="line">RUN chown -R nginx.nginx .</span><br><span class="line"></span><br><span class="line">ADD init.sh /init.sh</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/bin/bash&quot;,&quot;/init.sh&quot;]</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/08/pP68PxA.png" alt="pP68PxA.png" loading="lazy"></p>
<p><img src="https://s1.ax1x.com/2023/09/08/pP68krt.png" alt="pP68krt.png" loading="lazy"></p>
<ol start="4">
<li>然后用 vim 创建一个名为 <a href="http://init.sh">init.sh</a> 的 shell 脚本并写入以下内容：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim init.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">  </span><br><span class="line">php-fpm -D</span><br><span class="line"></span><br><span class="line">echo &quot;$1&quot; &gt;&gt; /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">nginx -g &#x27;daemon off;&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/08/pP68UG4.png" alt="pP68UG4.png" loading="lazy"></p>
<ol start="5">
<li>之后执行以下命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t kod:v1 . ; docker run -itd -p 25567:80 kod:v1 &#x27;#testtest&#x27;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/09/08/pP68sZ6.png" alt="pP68sZ6.png" loading="lazy"></p>
<ol start="6">
<li>
<p>在浏览器访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你的IP:25567/kodexplorer4.40/index.php</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="https://s1.ax1x.com/2023/09/08/pP68ydK.png" alt="pP68ydK.png" loading="lazy"></p>
<hr>
<p>示例：<a href="http://8.222.153.91:25569/kodexplorer4.40/index.php?user/login">可道云桌面</a></p>
<p>END</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>可道云</tag>
      </tags>
  </entry>
  <entry>
    <title>安利几个好用的网站</title>
    <url>/2023/05/02/%E5%AE%89%E5%88%A9%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h4 id="今天来分享几个十分好用的网站"><a class="header-anchor" href="#今天来分享几个十分好用的网站">¶</a>今天来分享几个十分好用的网站</h4>
<hr>
<h5 id="游戏类"><a class="header-anchor" href="#游戏类">¶</a>游戏类</h5>
<ul>
<li>
<p>rutracker</p>
<blockquote>
<p>网址：<a href="https://rutracker.net">https://rutracker.net</a></p>
</blockquote>
<p>这个网站可能很多人都知道，它是俄区最大的盗版游戏网站之一，在这里面，你可以找到绝大多数游戏</p>
<ul>
<li>注意：该网站目前是可以注册的，如果你有账号了，可以直接忽略第一二步，直接到第三步（Time：2023.5.24）</li>
</ul>
<p><img src="https://s1.ax1x.com/2023/05/02/p9Gz26O.png" alt="p9Gz26O.png" loading="lazy"></p>
<p>1.如果你直接在里面搜索的话，它是要你注册的，而想要不注册下载，你可以在地址栏中输入你要下载的<code>游戏名</code>+<code>site:http://rutracker.org</code> 然后回车,然后等地址栏加载出网址，将<code>rutracker.org</code>后缀改为<code>net</code></p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JSVHJ.png" alt="p9JSVHJ.png" loading="lazy"></p>
<p>2.在左边随便点一个，哪个能下载就点哪个<br>
<img src="https://s1.ax1x.com/2023/05/02/p9JCN59.png" alt="p9JCN59.png" loading="lazy"></p>
<p>3.之后在打开的页面下滑，找到通过磁力链接下载分发，点击它(注意，这个时候你要打开迅雷，要不然你点了打开没反应的)</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JSK9x.png" alt="p9JSK9x.png" loading="lazy"></p>
<p>4.在开始下载之后，右键正在下载的任务，选择种子另存为，不用管存在哪，只要你找的到就行</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JiIAg.png" alt="p9JiIAg.png" loading="lazy"></p>
<p>5.然后现在打开qBittorrent下载器（为什么不直接在迅雷里下？如果你能忍受它的下载速度的话那也不是不可以），将存好的种子拖入qBittorrent，点击ok就可以开始下载了</p>
<p>至于下载速度慢嘛，先点击工具，然后点击设置，选择BitTorrent，下滑找到自动将以下Tracker加入新的任务，然后将bt.txt中的内容全部复制粘贴到其中就好了</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JFAu6.png" alt="p9JFAu6.png" loading="lazy"></p>
<p>至于为什么你配置好BitTorrent后还是下载的那么慢，那就要看你下载的这个资源的做种的人多不多了，如果少的话那当然慢了，等你把资源下载完，会自动进入做种状态，你下载的东西其实都是从别人电脑里下的，所以，你下载完成之后也不要忘记帮助别人哦(<s>虽然我也只是偶尔做种</s>)</p>
<p>如果不想看图文版可以去看视频版，视频版做的不是特别好，将就着看吧</p>
<blockquote>
<p>视频版链接：【俄区网站游戏下载视频版】</p>
<p><a href="https://www.bilibili.com/video/BV1pk4y1E7qt/?share_source=copy_web&amp;vd_source=ddcb7a9992e8cac4ea71d734ce556e10">https://www.bilibili.com/video/BV1pk4y1E7qt/?share_source=copy_web&amp;vd_source=ddcb7a9992e8cac4ea71d734ce556e10</a></p>
<p>上面所有用到的软件我都打包好了（服务器小水管带宽，稍等一下吧）</p>
<p><a href="https://8.222.153.91:39811/down/8k6UNhtLiFIs.7z">下载链接</a> 提取码:YunYi</p>
</blockquote>
</li>
<li>
<p>byrutdb</p>
<blockquote>
<p>网址：<a href="https://byrutdb.org">https://byrutdb.org</a></p>
</blockquote>
<p>这也是一个俄区的游戏网站，但是与上面的一个不同的是，这个网站没有上面的那么麻烦（该网站经常会跳出edge的警告，直接忽略即可）</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9Jk9Z8.png" alt="p9Jk9Z8.png" loading="lazy"></p>
<p>1.进入首页之后，你可以直接搜索你要下载的游戏的英文名，然后选择你要下载的游戏点击进入，往下面划，在其他赠品里选一个下载，一定不要点上面的哪些绿色的下载按钮，因为很有可能下载到病毒，到目前为止我还没遇到过（悄悄告诉你，盗版网站也是有可联机版的）</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JkPIg.png" alt="p9JkPIg.png" loading="lazy"></p>
<p>2.之后它会下载一个种子文件，将这个文件拖入qBittorrent就行了</p>
</li>
</ul>
<p>上面的两个网站是相辅相成的</p>
<p>如何破解游戏？</p>
<p>这就要看游戏的附加信息了，每个游戏的附加信息都不一样，其实破解流程都差不多，无非就是替换文件，具体怎么操作，就要看你的自己灵活变通了</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JkOTU.png" alt="p9JkOTU.png" loading="lazy"></p>
<hr>
<h5 id="邮箱类"><a class="header-anchor" href="#邮箱类">¶</a>邮箱类</h5>
<ul>
<li>
<p><a href="http://mail1.io">mail1.io</a></p>
<blockquote>
<p>网址：<a href="https://basketball.group/">https://basketball.group/</a></p>
</blockquote>
<p>现在很多东西都需要邮箱注册，而你又不想透露自己的真实邮箱，那你就可以用这个网站生成一个临时电子邮箱</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JACOx.png" alt="p9JACOx.png" loading="lazy"></p>
</li>
</ul>
<h5 id="视频类"><a class="header-anchor" href="#视频类">¶</a>视频类</h5>
<ul>
<li>
<p>yhdmp</p>
<blockquote>
<p>网址：<a href="https://www.yhdmp.net">https://www.yhdmp.net</a></p>
</blockquote>
<p>这是一个看动漫的网站</p>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JAwn0.png" alt="p9JAwn0.png" loading="lazy"></p>
</li>
</ul>
<h5 id="图床"><a class="header-anchor" href="#图床">¶</a>图床</h5>
<ul>
<li>
<p>imgse</p>
<blockquote>
<p>网址：<a href="https://imgse.com">https://imgse.com</a></p>
</blockquote>
<p>路过图床是一个免费的存储图片的网站</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2023/05/02/p9JAJhQ.png" alt="p9JAJhQ.png" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>安利</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2023/04/27/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>Test测试</p>
<!-- more -->  
<p><img src="/images/test.jpg" alt="图片" loading="lazy"></p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>湖北飞young算号器</title>
    <url>/2023/06/13/%E6%B9%96%E5%8C%97%E9%A3%9Eyoung%E7%AE%97%E5%8F%B7%E5%99%A8/</url>
    <content><![CDATA[<hr>
<h4 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h4>
<ul>
<li>
<p>关于校园网</p>
<p>​		基本上上过大学的因该都知道校园网这个东西，由于在学校，单纯只用流量的话很不划算，所以大部分人都会去办一个校园网，但是校园网一般都会限制用户的登录数量，比如限制你只能登录三台设备等等，所以，有很多人都会选择去买一个破解路由器，但是这又有一个新的问题，破解路由器的价格几乎比正常路由器贵个一半左右，这是很不划算的。当然，你也可以选择不去买破解路由器，去用一些别的方法来绕过校园网的登录设备限制，比如抓包等等。</p>
</li>
<li>
<p>破解限制</p>
<p>​		如上面提到的，破解的方法无非也就那几种，其实破解路由器也是在路由器中内置了算法，使用破解路由器要方便一些。如果你不想花很大的代价，那其实也是有办法的，上有政策，下有对策。在网上其实早就有大佬去逆向过飞young的拨号程序，所以本文也只是沿着大佬们的足迹去走而已。</p>
</li>
</ul>
<hr>
<h4 id="正文"><a class="header-anchor" href="#正文">¶</a>正文</h4>
<p>​	我所使用的方法其实就是将飞young加密后的密码算出来，然后使用别人写的拨号程序来进行拨号认证而已（至于为什么要用别人的程序，因为我懒，不想自己写了）。</p>
<p>​	整个认证流程就是将加密后的密码及一些别的参数通过发包发送到飞young的认证服务器，让服务器误以为是飞young的拨号程序发的认证包，然后返回认证信息。</p>
<ul>
<li>
<p>密码加密算法</p>
<p>其实飞young的加密算法不止一套（听别的大佬说，貌似有三四套，淦），当初我算出来的密码和抓包抓出来的密码不管怎样都不一样，把我差点没气死。经过某位大佬的提点，才终于醒悟，我的算好器使用的算法是手机端的，而抓包抓的是pc端的程序，它两使用的算法都不一样，怎么可能算出来的密码一样（🌿此处省略一万字）</p>
<p>加密的流程其实就是先把初始密码rc4一下，再md5一下（其实还是很简单的有木有ಥ_ಥ）</p>
</li>
<li>
<p>程序</p>
<p>关于 飞young的密码程序我写了两个版本的，有 GUI 和无 GUI ， 建议使用无 GUI 版的（如果你不想折腾的话）</p>
<p>GUI 版纯粹是当初闲的，用 JavaFx 去写一个图形化界面。</p>
</li>
<li>
<p>使用</p>
<p><strong>重要：使用前你需要自行准备好一个能正常上网的路由器，并确保你或你宿舍中有人已经办理了一条宽带。</strong></p>
<p>先将算 31 天密码的程序下载下来，然后将 cyoung 也下载下来，运行程序，Password.txt 里面的东西就是你的 31 天密码，然后按照 cyoung 的文档填就好了</p>
</li>
</ul>
<p>注意：密码一般来说是你身份证后六位（如果你没有改密码的话）</p>
<h4 id="免责声明"><a class="header-anchor" href="#免责声明">¶</a>免责声明</h4>
<p>本博客所发布的一切文件仅限用于学习和研究目的；不得将上述内容用于商业或者非法用途，否则，一切后果请用户自负。您必须在下载后的24个小时之内，从您的电脑中彻底删除上述文件。 如果您喜欢该程序，请支持正版软件，购买注册，得到更好的正版服务。如有侵权请邮件与我联系处理。</p>
<hr>
<p>无 GUI 版：<a href="https://zero-li.lanzout.com/b04ws2pwj">点击下载</a> 密码:enwb</p>
<p>GUI 版：点击链接访问<a href="https://github.com/Zero-Ql/feiyoung">Github</a></p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次打暑假工的经历</title>
    <url>/2023/06/28/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%89%93%E6%9A%91%E5%81%87%E5%B7%A5%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>一切的不顺，全都来之于能力的不足</p>
<span id="more"></span>
<h4 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h4>
<p>​	相信很多人跟我一样，都想在两个月长的暑假里去找点零活干，好为自己挣点零花钱。说实话，感觉现在的暑假工越来越不好找了，我就是被坑了很多次之后才不得不向现实妥协（没办法，我可不想在家里再玩两月，所以只能找一个勉强能看的过去的地上班）</p>
<hr>
<h4 id="经历"><a class="header-anchor" href="#经历">¶</a>经历</h4>
<h5 id="第一次被骗"><a class="header-anchor" href="#第一次被骗">¶</a>第一次被骗</h5>
<p>​	说实话，在武汉的这三四天，我坐了最少六七十站的地铁了（属实给我整吐了），记得第一次找到的工作是去中百罗森当店员，当时我还是比较开心的，毕竟这年头找个工作不容易（因为我是不想进厂的，那死亡流水线属实干不来），但是让我万万没想到的是，已经快离校了，它给我整一个只招22岁的（🌿，太艹了）。没办法，只能重新找了，第二个是进厂，记得是一个格力的厂子，是通过中介找的，当时我室友是想去的，我不大愿意，当时距离离校只有一天左右，也没有其他的选择了（当天晚上我和我室友在网上疯狂投简历，真的不想进厂[倒]），到第二天上午的时候，我们投的简历终于有人回了（当时我真的是感动的不行，因为终于不用进厂了）。当天我们就去面试了（其实是找中介），顺利通过，我在网上找的是图书仓库的分拣员，一开始的时候我还抱有很大期望，但是有句话叫希望越大失望越大，我的这次经历就很好的印证了这句话，当时那个地方有一堆人，看到这么多人的时候我就感觉有一点不妙，果然，后面那中介就让我们去里面的一个房间看去哪个地方，结果等我们过去一看，踏么的全是厂，当时我就妈卖批，就不该信这个中介的。</p>
<h5 id="第二次被骗"><a class="header-anchor" href="#第二次被骗">¶</a>第二次被骗</h5>
<p>​	随后又有一个朋友找到了一个话务员的事，是替补习班招生的，于是我们只能从光谷广场跑到江岸区去找那个话务员，一开始面试的时候说的好好的，说有七天试用期，然后说如果试用期有人被淘汰了，其他人被录用了，被录用的不能全部一起跟着被淘汰的人一起走，我们当时也答应了，然后就是解决住的问题，当天晚上我们找了一个旅店是30块钱一晚上的便宜旅店，当时我们从地铁站出来之后已经是筋疲力尽了，毕竟拖着个行李跑了一整天，没累趴下已经算是万幸了，那个酒店的定位离我们出的地铁站口有个大概一公里的距离，当时我们是真的不想动了，于是便叫了一辆网约车，到达目的地定位之后打电话给那个客服，结果他告诉我定位有偏差？？？我心里直接一万头草泥马，当真是把他们祖上十八代都问候了一遍，因为那个旅馆的实际定位是在我们出地铁口不远的地方，而我们就相当与打网约车的钱白花了，淦@#！！！！</p>
<p>​	在我们历经十几分钟的路程之后，终于到了旅馆里，刚准备休息下又尼玛来了一个“好消息”，那个话务员的面试的人发消息说只要一个人，其他的人都不要。得，又被骗了呗，直接无语死，浪费我大半天时间，结果就给我来个这？</p>
<h5 id="第三次被骗"><a class="header-anchor" href="#第三次被骗">¶</a>第三次被骗</h5>
<p>​	没办法，只能继续在网上找了，因为我们不可能在武汉逗留很长时间的，时间和精力都不允许，大概过了一个多小时，在网上投的又一个简历有了回应，是一个零食店的，从这开始就是我们不幸的开端，那个招聘的说要办一个健康证，要三十块钱，当时我们本来是不信的，但是我们也别无选择了，根本没有多余的时间去消耗，况且也只是三十块钱而已，于是我们三个人一人转了三十一共九十过去，他让我们留一个能接短信的手机号，第二天下午一两点会有短信通知我们面试地方，我们信了，其实从理性的角度来说，是不应该相信的，但是我们还是心存一丝侥幸吧，选择了相信，当时我朋友在跟我一个同学打电话，我那个同学说他被中介骗了140块，当时我们还使劲的嘲笑他，可是报应来得是如此之快，在第二天的时候，我们在汉口火车站地铁站里等到了一点多，但是还是没有短信来，直到两点多的时候还是没有短信来，我们终于死心了，但是我还是不甘心，因为是在boss直聘上找的，它那个上面是有那个注册地址的，于是我准备过去跟他们理论理论，反正也不远，当时我的想法就是，哪怕我花50块钱的车费，我也要过去找你理论，虽然只是被骗了30块钱，但是我就是不甘心。</p>
<p>​	说做就做，我们直接坐地铁去那个定位的地方，到的时候已经是三点多了，因为那上面只有一个比较模糊的地址，于是我们准备去问一下，结果一问才知道，根本没有这个地，虽然我们已经做好了白跑一趟的准备，可是真的没找到还是有些不爽，这真的是我一生之耻啊，我唯一被骗的钱就是这三十块，玛德。</p>
<h5 id="第四次被骗"><a class="header-anchor" href="#第四次被骗">¶</a>第四次被骗</h5>
<p>​	 在所有的事情都尘埃落定之后已经是四五点钟了，这个时间点已经什么都做不了，没办法，只能先找个旅馆住着，在美团上找了一个五十块钱的旅店，住了一晚上之后，我朋友的朋友跟我们说有一个日结的事，问我们做不做，当时我们想着做一下也不是不行，毕竟出来用了这么多钱，回一点血也可以。于是我们拖着行李坐了半个小时的地铁，到了金银湖地铁站，我们刚出地铁口，正准备问具体在哪呢，我朋友的那个朋友就直接发消息说人满了，不要人了，真是气的我差点一口气没缓过来，我TM拖着行李坐了半个小时的地铁，结果你跟我说人满了，真是吐了，如果我没有带行李，那就算坐两个小时的地铁也无所谓，但是我提着大包小包的，直接人麻了。</p>
<h5 id="终章"><a class="header-anchor" href="#终章">¶</a>终章</h5>
<p>​	当时出地铁站已经是下午一点多了，再回去找别的事也来不及了，所以又在美团上找了一个三十多的旅馆，在晚上我们讨论了一下，都不想再到处跑了，最终决定稳妥一点，就直接来面试地铁安检了，来这之后还好没被骗，不然真的要心态炸裂。</p>
<p>​	在地铁安检我感觉唯一不好的就是有时候要住站，因为它是分为早班和晚班的，早班是上午六点多上到下午两点，而晚班是下午两点上到晚上十一点多，一般来说是一个晚班和一个早班连起来上的，而住站顾名思义，就是晚上住地铁站里，那条件可真算不上好，因为是晚上十一点多下班，稍微搞个什么就十二点了，然后第二天起来上早班，就是说要五点多就起来，然后上到下午两点下班，也就是说你只能睡四个多小时，我上班的时候真的怕自己啥时候就猝死了（难怪他们面试的要看体检报告的心电图，毕竟只能睡四个多小时…）。</p>
<h4 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h4>
<p>​	身为过来人，我给想在武汉找暑假工的一些兄弟一点建议，那就是千万千万别在武汉找暑假工，真的，就像我一个朋友说的一样，武汉就是一个小缅甸，到处都是骗子和中介，中介全部都是一窝的，所以找暑假工最好是去外地找。</p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>记录</tag>
        <tag>暑假工</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次电脑启动原神蓝屏解决方案</title>
    <url>/2023/05/06/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B5%E8%84%91%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%A5%9E%E8%93%9D%E5%B1%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<ul>
<li>
<p>原因：</p>
<p>电脑启动原神时蓝屏，退出代码为 kernel-security_check_failure（内核安全检查失败）</p>
</li>
<li>
<p>解决方法：</p>
<p>进入设置 windows 安全中心将内核隔离的内核模式硬件强制堆栈保护关闭即可</p>
</li>
</ul>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈看完《孤注一掷》的感想</title>
    <url>/2023/09/16/%E8%B0%88%E8%B0%88%E7%9C%8B%E5%AE%8C%E3%80%8A%E5%AD%A4%E6%B3%A8%E4%B8%80%E6%8E%B7%E3%80%8B%E7%9A%84%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[<h4 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h4>
<p>我并没有什么文采，也不懂什么高深的遣词造句，此篇如其名，只是谈一下我对看完这部电影的浅薄感想！</p>
<p>就这么多吧，将就着看看就成，不必当真。</p>
<hr>
<h4 id="1-起因"><a class="header-anchor" href="#1-起因">¶</a>1. 起因</h4>
<p>本来我对孤注一掷并没有什么观影欲望，单纯只是想出去透透气，看个电影放松一下，毕竟在学校一直呆着，每天差不多是天天早八了，而且基本上每天都有最少六节课，不是在实训楼就是教室跟宿舍，我学校小，也没什么地方可去，就怕啥时候憋出病来😅，所以在今天（星期六），跟舍友商量了一下，准备去看孤注一掷。</p>
<h4 id="2-观影"><a class="header-anchor" href="#2-观影">¶</a>2. 观影</h4>
<p>看完电影我感觉有太多感触了，回来的路上我不断的有想法冒出来，但是到了宿舍，创建了这篇文章，此时竟然不知如何写起。</p>
<p>我认为电影里的主角是不幸的，同时也是幸运的，不幸是因为在职场中竞争失利，毕竟一个普通人，在中国这个人情社会中，想要活下去没有背景和人脉是不可能的，潘生就是一个典型的例子，后面他一气之下出国，被拐入诈骗集团，这些都是他的不幸。但幸运的是，有人还记得他，他并不是孤单一人，即使被拐入诈骗集团数次求救失败他也没有放弃，如果是另外一个人，估计早就被彻底 PUA 了，而在电影的后段，如果没有阿才放掉梁安娜，那也就不会有最后的获救了，所以他是幸运的，因为并不是所有人都有这个运气，绝大多数人很可能穷其一生也不可能逃出去，就像其中的那个路人甲，他也曾以为自己得救了，但没想到还是会被卖给另一个诈骗团伙，最后更是惨死。</p>
<p>还有里面的阿天，以及梁安娜，他们都有一个共同点，那就是那么明显的骗局他们为什么还会上当？其实所有的问题都是一个原因造成的，他们都需要钱，在这里面我有点想不通的就是阿天他的条件明显很不错，比如硕士毕业，有房有车，还有稳定的工作，以及还有一个女朋友，这他娘的还要什么自行车？我并不能理解他为什么急需钱，可能是我们的眼界不同吧，亦可能是为了所谓的虚荣心。</p>
<p>当然，将我们的处境换位一下，在你急需用钱的时候，突然出现了一个可以赚快钱的机会，我也可能会做出和他们同样的选择，哪怕有一定可能是诈骗，毕竟人总是抱着侥幸心理的，就像我们为一件事而犹豫时，此时我们会去询问周围的朋友，他们的话有可能是劝阻你，但哪怕有百分之99的人反对你，可只要有一个人支持你，你就会毫不犹豫的去做，其实早在你去问他们之前你心里就已经有了答案，只不过你缺少一个说服自己的借口罢了。电影中的梁安娜就是如此，在一个刚认识的闺蜜的口头保证下，她也相信了那张被画的圆圆的大大的饼。</p>
<h4 id="3-结语"><a class="header-anchor" href="#3-结语">¶</a>3. 结语</h4>
<p>其实看完电影之后，我最大的感触就是人心不足蛇吞象，人的欲望是不断增长的，一旦开始就无法停下，这也导致了阿天的家破人亡，他最大的弱点就是贪心，这也是人这种生物的共性，我也同样如此，我从来不认为我是一个高尚的人，我同样自私且自利，但人要懂得控制自己的欲望，如果被欲望击垮，那就会堕入无边的深渊，再也无法上岸.</p>
<p>我从电影中所获取的最大收获即是人不能太过贪心，天下也没有那么多好事等着你去做，真正的好事早就被那些有背景的人瓜分了，哪还轮的到你，自己要擦亮眼睛，才能不被骗。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>运算符级别比较</title>
    <url>/2023/05/02/%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BA%A7%E5%88%AB%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<hr>
<h3 id="运算符级别"><a class="header-anchor" href="#运算符级别">¶</a>运算符级别</h3>
<ul>
<li>* /</li>
<li>+ -</li>
</ul>
<h6 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h6>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s1.matches(<span class="string">&quot;[*/]&quot;</span>)&amp;&amp;s2.matches(<span class="string">&quot;[+-]&quot;</span>)) <span class="comment">//相同级别</span></span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s1.matches(<span class="string">&quot;[*/]&quot;</span>)&amp;&amp;s2.matches(<span class="string">&quot;[+-]&quot;</span>)) <span class="comment">//s1&gt;s2</span></span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="comment">//code</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2023/04/11/ppLkjaj.md.png" alt="ppLkjaj.md.png" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>集合-Map</title>
    <url>/2023/05/02/%E9%9B%86%E5%90%88-Map/</url>
    <content><![CDATA[<h4 id="Map接口-双列队列"><a class="header-anchor" href="#Map接口-双列队列">¶</a>Map接口(双列队列)</h4>
<ul>
<li>
<p><code>HashMap</code>和<code>LinkedHashMap</code></p>
<p><code>HashMap</code>实现了<code>Map</code>接口，而<code>LinkedHashMap</code>继承自<code>HashMap</code>类</p>
<ul>
<li><code>hashmap</code>和<code>linkedhashmap</code>的区别
<ul>
<li><code>hashmap</code>采用了哈希表实现<code>map</code>接口，但是它的存储是无序的</li>
<li><code>linkedhashmap</code>同样也采用了哈希表实现，但不同的是它同时采用了链表结构，这使得它的存储是有序的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="HashMap构造方法"><a class="header-anchor" href="#HashMap构造方法">¶</a>HashMap构造方法</h5>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其他构造方法都是在此基础上衍生而来</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    	<span class="comment">//initialCapacity 初始容量</span></span><br><span class="line">    	<span class="comment">//loadFactor 初始系数</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="HashMap的常用方法"><a class="header-anchor" href="#HashMap的常用方法">¶</a>HashMap的常用方法</h5>
<ul>
<li>
<p><em><code>get()</code></em>、<em><code>put()</code></em>、<em><code>remove()</code></em></p>
<p><code>get()</code></p>
<ul>
<li>返回指定键的键值</li>
</ul>
<p><code>put()</code></p>
<ul>
<li>将指定的键值装入列表</li>
</ul>
<p><code>remove()</code></p>
<ul>
<li>删除指定健的键值，删除后健的值为<code>null</code></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//初始容量为5，初始系数为0.75</span></span><br><span class="line">        <span class="comment">//可以使用泛型指定存储类型</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">hashmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;(<span class="number">5</span>,<span class="number">0.75</span>);</span><br><span class="line">        <span class="comment">//key为键值1，value为1</span></span><br><span class="line">        hashmap.put(<span class="string">&quot;键值1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//返回键为“键值1”的对应键值value</span></span><br><span class="line">        <span class="comment">//注意：此value为Object类型,输出会自动调用toString方法将值转换为String</span></span><br><span class="line">        System.out.println(hashmap.get(<span class="string">&quot;键值1&quot;</span>));</span><br><span class="line">        <span class="comment">//删除键为“键值1”的对应值value，删除后键“键值1”的值为null</span></span><br><span class="line">        hashmap.remove(<span class="string">&quot;键值1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LinkedHashMap</code>的构造方法同<code>HashMap</code>相同</p>
<ul>
<li>
<p><em><code>containsKey</code></em>、<em><code>containsValue</code></em>、<em><code>isEmpty</code></em></p>
<p><code>containskey</code></p>
<ul>
<li>如果此列表中包含指定的键就返回true，反之false</li>
</ul>
<p><code>containsValue</code></p>
<ul>
<li>如果此列表将一个或多个健映射到此键值就返回true，反之false</li>
</ul>
<p><code>isEmpty</code></p>
<ul>
<li>如果此列表不包含健和键值就返回true，反之false</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">hashmap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        hashmap.put(<span class="string">&quot;键值&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//查看hashmap中是否包含健 &quot;键值&quot;</span></span><br><span class="line">       	<span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> hashmap.containskey(<span class="string">&quot;键值&quot;</span>);</span><br><span class="line">        <span class="comment">//查看hashmap中是否有指定值的映射</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> hashmap.containsValue(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//查看hashmap中是否包含键值对</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> hashmap.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序执行结果为</p>
<p><code>b1=true</code> <code>b2=true</code> <code>b3=false</code></p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>集合接口的继承及实现概览</title>
    <url>/2023/05/14/%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h5 id="Map-根接口-包含键和值"><a class="header-anchor" href="#Map-根接口-包含键和值">¶</a>Map    --根接口(包含键和值)</h5>
<p>直接继承的接口</p>
<ul>
<li>Bindings</li>
<li>ConcurrentMap
<ul>
<li>ConcurrentNavigableMap&lt;K,V&gt;</li>
</ul>
</li>
<li>SoredMap
<ul>
<li>NavigableMap&lt;K,V&gt;</li>
</ul>
</li>
</ul>
<p>所有实现Map接口的类</p>
<p><code>AbstractMap</code>,<br>
<code>Attributes</code>,<br>
<code>AuthProvider</code>,<br>
<code>ConcurrentHashMap</code>,<br>
<code>ConcurrentSkipListMap</code>,<br>
<code>EnumMap</code>,<br>
<code>HashMap</code>,<br>
<code>Hashtable</code>,<br>
<code>Headers</code>,<br>
<code>IdentityHashMap</code>,<br>
<code>LinkedHashMap</code>,<br>
<code>PrinterStateReasons</code>,<br>
<code>Properties</code>,<br>
<code>Provider</code>,<br>
<code>RenderingHints</code>,<br>
<code>SimpleBindings</code>,<br>
<code>TabularDataSupport</code>,<br>
<code>TreeMap</code>,<br>
<code>UIDefaults</code>,<br>
<code>WeakHashMap</code></p>
<h5 id="Collection-根接口-只有元素"><a class="header-anchor" href="#Collection-根接口-只有元素">¶</a>Collection    --根接口(只有元素)</h5>
<p>直接继承的接口</p>
<ul>
<li>BeanContext
<ul>
<li>BeanContextServices</li>
</ul>
</li>
<li>Queue<E>
<ul>
<li>BlockingQueue<E>
<ul>
<li>BlockingDeque<E></li>
<li>TransferQueue<E></li>
</ul>
</li>
<li>Deque<E></li>
</ul>
</li>
<li>List<E></li>
<li>Set<E>
<ul>
<li>EventSet</li>
<li>SortedSet<E>
<ul>
<li>NavigableSet<E></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>所有实现Collection的类</p>
<p><code>AbstractCollection</code>,<br>
<code>AbstractList</code>,<br>
<code>AbstractQueue</code>,<br>
<code>AbstractSequentialList</code>,<br>
<code>AbstractSet</code>,<br>
<code>ArrayBlockingQueue</code>,<br>
<code>ArrayDeque</code>,<br>
<code>ArrayList</code>,<br>
<code>AttributeList</code>,<br>
<code>BeanContextServicesSupport</code>, <code>BeanContextSupport</code>, <code>ConcurrentHashMap.KeySetView</code>, <code>ConcurrentLinkedDeque</code>,<br>
<code>ConcurrentLinkedQueue</code>,<br>
<code>ConcurrentSkipListSet</code>,<br>
<code>CopyOnWriteArrayList</code>,<br>
<code>CopyOnWriteArraySet</code>,<br>
<code>DelayQueue</code>,<br>
<code>EnumSet</code>,<br>
<code>HashSet</code>,<br>
<code>JobStateReasons</code>,<br>
<code>LinkedBlockingDeque</code>,<br>
<code>LinkedBlockingQueue</code>,<br>
<code>LinkedHashSet</code>,<br>
<code>LinkedList</code>,<br>
<code>LinkedTransferQueue</code>,<br>
<code>PriorityBlockingQueue</code>,<br>
<code>PriorityQueue</code>,<br>
<code>RoleList</code>,<br>
<code>RoleUnresolvedList</code>,<br>
<code>Stack</code>,<br>
<code>SynchronousQueue</code>,<br>
<code>TreeSet</code>,<br>
<code>Vector</code></p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>shell脚本笔记-3</title>
    <url>/2023/12/16/shell%E8%84%9A%E6%9C%AC%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2023年度总结</title>
    <url>/2024/02/09/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h3>
<p>先在这里提前祝大家新年快乐！新的一年要开开心心，顺顺利利的。🧨爆竹🎇烟花💥爆炸✨闪亮</p>
<hr>
<p>​	在2023年中，我拥有了人生中第一台云服务器，虽然是和朋友一起合租的，但是还是很开心，还搭建了人生中第一个个人博客，同时，还学会了很多东西，虽然是些皮毛，但是依然令人高兴，而这些都是值得铭记的。有开心的同时一样有伤心，这才是世间的规则，在这一年，继我奶奶走了之后，我爷爷也在十一月份离我们而去了，老天爷总是不公的，连留给我见最后一面的时间都不舍得给。</p>
<p>​	在过去的一年中，经历了许许多多的事情，有开心，也有过不愉快，但是，这些都不重要了，因为已经过去了，人是要活在未来的，向前看才行。</p>
<p>​	希望新的一年越来越好，能完成自己想做的事情。</p>
<p>​	2024年的新年愿望是能有一台属于自己的服务器，能遇见一个喜欢的人。如此，安好。</p>
<p>​	最后附上一张烟花</p>
<p><img src="/images/yh.png" alt="烟花" loading="lazy"></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>记录</tag>
        <tag>2023</tag>
        <tag>年度总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Selenium 的使用</title>
    <url>/2024/03/05/Selenium-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="Selenium-介绍"><a class="header-anchor" href="#Selenium-介绍">¶</a><code>Selenium</code> 介绍</h3>
<p><code>selenium</code> 是一个广泛使用的模拟浏览器运行的库，它是一个用于 <code>Web</code> 应用程序测试的工具。<code>Selenium</code> 测试直接运行在浏览器中，就像真正的用户在操作一样，并且支持大多数现代 <code>Web</code> 浏览器。</p>
<h3 id="Selenium-自动化测试的八种定位方法"><a class="header-anchor" href="#Selenium-自动化测试的八种定位方法">¶</a><code>Selenium</code> 自动化测试的八种定位方法</h3>
<h4 id="使用场景："><a class="header-anchor" href="#使用场景：">¶</a>使用场景：</h4>
<p>① 优先用<code>id</code>、<code>name</code>（保证唯一性）</p>
<p>② 是否是超链接，是超链接用<code>link_text</code>、<code>partial_link_text</code>，否则用<code>css_selector</code>、<code>xpath</code></p>
<p>③ <code>class_name</code>、<code>tag_name</code>很少用，因为这俩个难以保证被定为元素或属性的唯一性</p>
<h4 id="ID-定位"><a class="header-anchor" href="#ID-定位">¶</a><code>ID</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.ID,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(by=By.ID, value=<span class="string">&quot;username&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Name-定位"><a class="header-anchor" href="#Name-定位">¶</a><code>Name</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.NAME,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(by=By.NAME, value=<span class="string">&quot;username&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Class-定位"><a class="header-anchor" href="#Class-定位">¶</a><code>Class</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.CLASS_NAME,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(by=By.CLASS_NAME, value=<span class="string">&quot;username&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Tag-Name-定位"><a class="header-anchor" href="#Tag-Name-定位">¶</a><code>Tag_Name</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.TAG_NAME,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(by=By.TAG_NAME,value=<span class="string">&quot;input&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Link-Text-定位"><a class="header-anchor" href="#Link-Text-定位">¶</a><code>Link_Text</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.LINK_TEXT,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(by=By.LINK_TEXT,value=<span class="string">&quot;登&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Partial-Link-定位"><a class="header-anchor" href="#Partial-Link-定位">¶</a><code>Partial_Link</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.PARTIAL_LINK,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(by=By.PARTIAL_LINK,value=<span class="string">&quot;登录&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Xpath-定位"><a class="header-anchor" href="#Xpath-定位">¶</a><code>Xpath</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.XPATH,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 XPATH 定位带有 id=&#x27;login&#x27; 属性和 name=&#x27;user&#x27; 属性的 input 标签</span></span><br><span class="line">driver.find_element(by=By.XPATH,value=<span class="string">&quot;//input[@id=&#x27;login&#x27; and @name=&#x27;user&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Css-selector-定位"><a class="header-anchor" href="#Css-selector-定位">¶</a><code>Css_selector</code> 定位</h4>
<p>方法原型：</p>
<p><code>driver.find_element(By.CSS_SELECTOR,value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.find_element(by=By.CSS_SELECTOR,value=<span class="string">&quot;input#login&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>自动化测试笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>python</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>JUnit</title>
    <url>/2024/03/11/JUnit/</url>
    <content><![CDATA[<h3 id="JUnit-介绍"><a class="header-anchor" href="#JUnit-介绍">¶</a>JUnit 介绍</h3>
<p>在编写程序的过程中，我们常常需要对一个单独的模块进行测试，以判断其是否符合要求。</p>
<h4 id="Test-注解"><a class="header-anchor" href="#Test-注解">¶</a><code>@Test</code> 注解</h4>
<p>一般来说，通过 <code>@Test</code> 注解过的方法就是测试方法，测试方法可以脱离 <code>man()</code> 方法独立运行。</p>
<h4 id="参数化测试"><a class="header-anchor" href="#参数化测试">¶</a>参数化测试</h4>
<p>为了确保单元测试的严谨性，通常会模拟不同的测试数据来测试方法的处理能力，为此我们需要编写大量的单元测试方法，可这些测试的方法大体框架都是差不多的，它们的结构都是相同的，不同的仅仅是数据和期望值，为此，我们可以使用参数化测试。</p>
<h5 id="参数化测试条件"><a class="header-anchor" href="#参数化测试条件">¶</a>参数化测试条件</h5>
<ol>
<li>对需要测试的类添加 <code>@RunWith(Parameterized.class)</code> 注解</li>
<li>用于存放测试数据及期望值的变量都要声明为私有变量</li>
<li>将上一步的私有变量作为入参创建构造方法并为其赋值</li>
<li>创建一个公共的静态方法，此方法的返回值为集合 <code>Collection</code> ，并且此方法需要被 <code>@Parameters</code> 注解</li>
<li>使用定义的私有变量编写测试方法</li>
</ol>
<p>Demo:</p>
<p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fun.zero.li;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized;</span><br><span class="line"><span class="keyword">import</span> org.junit.runners.Parameterized.Parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(Parameterized.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FuntionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">usesrname</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">FuntionTest</span><span class="params">(String msg, String username, String password)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.usesrname = username;</span><br><span class="line">		<span class="built_in">this</span>.password = password;</span><br><span class="line">		<span class="built_in">this</span>.msg = msg;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回集合</span></span><br><span class="line">	<span class="meta">@Parameters</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Collection&lt;Object[]&gt; get_data() &#123;</span><br><span class="line">		Object[][] data = <span class="keyword">new</span> <span class="title class_">Object</span>[][] &#123; </span><br><span class="line">            &#123; <span class="string">&quot;用户名或密码不能为空&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span> &#125;, </span><br><span class="line">            &#123; <span class="string">&quot;登录成功&quot;</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123&quot;</span> &#125;,</span><br><span class="line">			&#123; <span class="string">&quot;请输入正确的用户名&quot;</span>, <span class="string">&quot;ad&quot;</span>, <span class="string">&quot;123&quot;</span> &#125;, </span><br><span class="line">            &#123; <span class="string">&quot;请输入正确的密码&quot;</span>, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;123456&quot;</span> &#125;, </span><br><span class="line">            &#123; <span class="string">&quot;请输入正确的用户名和密码&quot;</span>, <span class="string">&quot;ad&quot;</span>, <span class="string">&quot;123456&quot;</span> &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="keyword">return</span> Arrays.asList(data);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试，通过断言判断测试是否成功</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFuntion_data</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">funtion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Funtion</span>();</span><br><span class="line">		assertEquals(msg, funtion.funtion_data(usesrname, password));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被测试的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fun.zero.li;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Funtion</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">funtion_data</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (username.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; password.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">			msg = <span class="string">&quot;用户名或密码不能为空&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(username.equals(<span class="string">&quot;admin&quot;</span>)&amp;&amp; password.equals(<span class="string">&quot;123&quot;</span>))&#123;</span><br><span class="line">			msg = <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!(username.equals(<span class="string">&quot;admin&quot;</span>))&amp;&amp; password.equals(<span class="string">&quot;123&quot;</span>))&#123;</span><br><span class="line">			 msg = <span class="string">&quot;请输入正确的用户名&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(username.equals(<span class="string">&quot;admin&quot;</span>)&amp;&amp; !(password.equals(<span class="string">&quot;123&quot;</span>)))&#123;</span><br><span class="line">			msg = <span class="string">&quot;请输入正确的密码&quot;</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			msg = <span class="string">&quot;请输入正确的用户名和密码&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> msg;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果示例：</p>
<p><img src="https://s21.ax1x.com/2024/03/10/pFy2pWD.png" alt="pFy2pWD.png" loading="lazy"></p>
<p>​	还有一些其他的参数化测试方法请自行去<a href="https://github.com/junit-team/junit4/wiki/Parameterized-tests">参数化测试 ·junit-team/junit4 维基 (github.com)</a>查看</p>
<h4 id="断言"><a class="header-anchor" href="#断言">¶</a>断言</h4>
<p>断言(assertion)是一种在程序中的一阶逻辑(如：一个结果为真或假的逻辑判断式)，目的为了表示与验证软件开发者预期的结果——当程序执行到断言的位置时，对应的断言应该为真。若断言不为真时，程序会中止执行，并给出错误信息。</p>
<p>常用<code>API</code>：</p>
<ul>
<li>
<p><code>assertEquals()</code>：检测两个值是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">100</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertTrue()</code>：检测条件是否为真</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertTrue(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertFalse(true)</code>：检测条件是否为假</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertFalse(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertNotNull()</code>：检测不为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertNotNull(getClass());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertNull()</code>：检测为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertNull(getClass())</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertNotSame()</code>：检测两个相关对象是否不指向同一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertNotSame(getClass(), getClass());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertSame()</code>：检测两个相关对象是否指向同一个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertSame(getClass(), getClass())</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertArrayEquals()</code>：检测两个数组是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertArrayEquals(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;().toArray(), <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;().toArray());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Hamcrest"><a class="header-anchor" href="#Hamcrest">¶</a><code>Hamcrest</code></h5>
<p><code>Hamcrest</code> 是一款用于校验的 Java 的单元测试框架，可以组合创建灵活的表达的匹配器进行断言。</p>
<p><code>JUnit</code> 结合 <code>Hamcrest</code> 提供了一个全新的断言语法—— <code>assertThat</code>。程序员可以只使用 <code>assertThat</code> 一个断言语句，结合 <code>Hamcrest</code> 提供的匹配符，就可以表达全部的测试思想。</p>
<p>要使用 <code>Hamcrest</code> 断言，需要先使用 <code>assertThat</code> 来声明一个断言，然后再在内部进行具体匹配器的断言细节，期望值和实际值进行对比。</p>
<h5 id="一般匹配符断言"><a class="header-anchor" href="#一般匹配符断言">¶</a>一般匹配符断言</h5>
<ul>
<li>
<p><code>assertThat()</code>：<code>allOf</code>表示括号里的所有断言都要成立才测试通过，相当于 <code>&amp;&amp;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 由于 eclipse 这个水货识别不了 allof ，所以我通过包名的方式引用</span><br><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, org.hamcrest.core.AllOf.allOf(startsWith(<span class="string">&quot;he&quot;</span>),containsString(<span class="string">&quot;wo&quot;</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>anyOf</code> 表示括号里的所有断言只要有一个成立测试就通过，相当于 <code>||</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>,org.hamcrest.core.AnyOf.anyOf(startsWith(<span class="string">&quot;wo&quot;</span>),containsString(<span class="string">&quot;hel&quot;</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>anything</code> 表示无论是什么条件，测试都为<code>true</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, org.hamcrest.core.IsAnything.anything());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>is</code> 表示如果前面给出的期望值等于后面给出的值，则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, org.hamcrest.core.Is.is(<span class="string">&quot;hello world&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>not</code> 与 is 正好相反，如果前面给出的期望值不等于后面给出的值，则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello&quot;</span>, org.hamcrest.core.IsNot.not(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="字符串相关匹配符"><a class="header-anchor" href="#字符串相关匹配符">¶</a>字符串相关匹配符</h5>
<ul>
<li>
<p><code>assertThat()</code>：<code>containsString</code> 表示如果前面的期望值包含后面的子字符串则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, containsString(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>startsWith</code>表示如果前面的期望值是以后面的子字符串开头则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, startsWith(<span class="string">&quot;hell&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>endsWith</code>表示如果前面的期望值是以后面的子字符串结尾则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, endsWith(<span class="string">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>equalTo</code>表示如果前面的期望值跟后面的字符串相等则测试通过，相当于 <code>equals()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, equalTo(<span class="string">&quot;hello world&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>equalToIgnoringCase</code>表示如果后面的值在忽略大小写的情况下等于期望值则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, equalToIgnoringCase(<span class="string">&quot;HELLO world&quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>equalToIgnoringWhiteSpace</code>表示如果后面的值在忽略前后任意个空格的情况下等于期望值则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="string">&quot;hello world&quot;</span>, equalToIgnoringWhiteSpace(<span class="string">&quot;   hello world    &quot;</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="数值相关匹配符"><a class="header-anchor" href="#数值相关匹配符">¶</a>数值相关匹配符</h5>
<ul>
<li>
<p><code>assertThat()</code>：<code>closeTo</code>匹配符表明如果所<strong>测试的浮点型数在1.0±0.03范围之内</strong>则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="number">1.03</span>, is(closeTo(<span class="number">1.0</span>, <span class="number">0.03</span>)));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>greaterThan</code>匹配符表明如果所<strong>测试的数值大于1</strong>则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="number">2</span>, greaterThan(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>lessThan</code>匹配符表明如果所<strong>测试的数值小于2</strong>则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="number">1</span>, lessThan(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>greaterThanOrEqualTo</code>匹配符表明如果所<strong>测试的数值大于等于1</strong>则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="number">1</span>, greaterThanOrEqualTo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>lessThanOrEqualTo</code>匹配符表明如果所<strong>测试的数值小于等于1</strong>则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(<span class="number">1</span>, lessThanOrEqualTo(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="集合相关匹配符"><a class="header-anchor" href="#集合相关匹配符">¶</a>集合相关匹配符</h5>
<ul>
<li>
<p><code>assertThat()</code>：<code>hasEntry</code>匹配符表明如果测试的<strong>Map对象含有一个键值为&quot;bar&quot;对应元素值为&quot;foo&quot;的Entry项</strong>则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(myMap, hasEntry(“bar”, “foo”));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>hasItem</code>匹配符表明如果测试的<strong>迭代对象含有元素以ba开头项</strong>则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ssertThat(Arrays.asList(“foo”, “bar”), hasItem(startsWith(“ba”)));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>hasKey</code>匹配符表明如果测试的**Map对象含有键值“bar”**则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(myMap, hasKey(“bar”));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>assertThat()</code>：<code>hasValue</code>匹配符表明如果测试的**Map对象含有元素值“foo”**则测试通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertThat(myMap, hasValue(“foo”))	;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>单元测试笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON</title>
    <url>/2024/04/03/JSON/</url>
    <content><![CDATA[<h3 id="JSON-简介"><a class="header-anchor" href="#JSON-简介">¶</a>JSON 简介</h3>
<blockquote>
<p><code>JSON</code>: <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation( <code>JavaScript</code> 对象表示法)</p>
<p><code>JSON</code> 是存储和交换文本信息的语法，类似 <code>XML</code>。</p>
<p><code>JSON</code> 比 <code>XML</code> 更小、更快，更易解析。</p>
<p><code>JSON</code> 易于人阅读和编写。</p>
<p><code>C</code>、<code>Python</code>、<code>C++</code>、<code>Java</code>、<code>PHP</code>、<code>Go</code>等编程语言都支持 <code>JSON</code></p>
</blockquote>
<p>例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sites&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;bing&quot;</span> <span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;www.bing.com&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;google&quot;</span> <span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;www.google.com&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;baidu&quot;</span> <span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;www.baidu.com&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="对象"><a class="header-anchor" href="#对象">¶</a>对象</h3>
<p>在 <code>JSON</code> 中使用<code>&#123;&#125;</code>来定义一个对象。左括号<code>&#123;</code>开始，右括号<code>&#125;</code>结束。每个 <code>&quot;键&quot;</code> 后跟一个冒号 <code>:</code> ，名称/值对使用逗号 <code>,</code> 分隔</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">20</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="嵌套对象"><a class="header-anchor" href="#嵌套对象">¶</a>嵌套对象</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;student&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;namelist&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;name1&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;name2&quot;</span><span class="punctuation">:</span><span class="string">&quot;李四&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;agelist&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">			<span class="attr">&quot;age1&quot;</span><span class="punctuation">:</span><span class="number">20</span><span class="punctuation">,</span></span><br><span class="line">			<span class="attr">&quot;age2&quot;</span><span class="punctuation">:</span><span class="number">21</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h3>
<p>中括号 <code>[]</code> 保存的数组是值（<code>value</code>）的有序集合。一个数组以左中括号 <code>[</code> 开始， 右中括号 <code>]</code> 结束，值之间使用逗号 <code>,</code> 分隔。</p>
<p>值（<code>value</code>）可以是双引号括起来的字符串（<code>string</code>）、数值(<code>number</code>)、<code>true</code>、<code>false</code>、 <code>null</code>、对象（<code>object</code>）或者数组（<code>array</code>），它们是可以嵌套，值不能为键值对。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;str&quot;</span><span class="punctuation">,</span><span class="number">100</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h4 id="嵌套数组"><a class="header-anchor" href="#嵌套数组">¶</a>嵌套数组</h4>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;num&quot;</span><span class="punctuation">:</span> <span class="number">2</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;李四&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h3 id="JSON-parse"><a class="header-anchor" href="#JSON-parse">¶</a><code>JSON.parse()</code></h3>
<p>此方法为 <code>JavaScript</code> 的内置函数，用于将 <code>JSON</code> 字符串解析为原生 <code>JavaScript</code> 对象或值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(text[, reviver])</span><br></pre></td></tr></table></figure>
<p><code>text</code></p>
<p>​	要被解析成 <code>JavaScript</code> 值的字符串</p>
<p><code>reviver</code>(可选)</p>
<p>​	转换器，如果传入该参数 (函数)，可以用来修改解析生成的原始值，调用时机在 <code>parse</code> 函数返回之前</p>
<p>返回值</p>
<p>​	与给定的 <code>JSON text</code> 相对应的 <code>Object</code>、<code>Array</code>、<code>string</code>、<code>number</code>、<code>boolean</code> 或者 <code>null</code> 值</p>
<p>异常</p>
<p>​	若传入的字符串不符合 JSON 规范，则会抛出此异常</p>
<p>使用 <code>reviver</code> 函数</p>
<blockquote>
<p>如果指定了 <code>reviver</code> 函数，则解析出的 <code>JavaScript</code> 值（解析值）会经过一次转换后才将被最终返回（返回值）。更具体点讲就是：解析值本身以及它所包含的所有属性，会按照一定的顺序（从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身）分别的去调用 <code>reviver</code> 函数，在调用过程中，当前属性所属的对象会作为 <code>this</code> 值，当前属性名和属性值会分别作为第一个和第二个参数传入 <code>reviver</code> 中。如果 <code>reviver</code> 返回 <code>undefined</code>，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。</p>
<p>当遍历到最顶层的值（解析值）时，传入 <code>reviver</code> 函数的参数会是空字符串 <code>&quot;&quot;</code>（因为此时已经没有真正的属性）和当前的解析值（有可能已经被修改过了），当前的 <code>this</code> 值会是 <code>&#123;&quot;&quot;: 修改过的解析值&#125;</code>，在编写 <code>reviver</code> 函数时，要注意到这个特例。（这个函数的遍历顺序依照：从最内层开始，按照层级顺序，依次向外遍历）</p>
</blockquote>
<p>更多请参阅:</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse">JSON.parse() - JavaScript | MDN (mozilla.org)</a></p>
<p><a href="https://www.runoob.com/json/json-tutorial.html">JSON 教程 | 菜鸟教程 (runoob.com)</a></p>
<hr>
<p>END</p>
]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>JavaScript</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb</title>
    <url>/2024/04/16/JavaWeb/</url>
    <content><![CDATA[<h3 id="域"><a class="header-anchor" href="#域">¶</a>域</h3>
<ul>
<li>
<p>域是类的属性或数据成员，用于表示对象的特征或属性。</p>
</li>
<li>
<p>它可以包括各种数据类型，可以是一个类变量，一个对象变量，一个对象方法变量或者是一个函数的参数。</p>
</li>
</ul>
<h4 id="作用"><a class="header-anchor" href="#作用">¶</a>作用</h4>
<ul>
<li>域存储对象的状态信息，使得我们可以在对象内部访问和操作这些数据。</li>
<li>通过域，我们可以描述对象的特性，例如一个人的姓名、年龄、工资等。</li>
</ul>
<h4 id="域对象"><a class="header-anchor" href="#域对象">¶</a>域对象</h4>
<p>域对象是一种在 <code>Java Web</code> 应用中用于存储数据的容器。它们可以在不同的 <code>Servlet</code> 之间共享数据，以便在整个应用程序生命周期内保持数据的一致性。域对象主要包括以下三种：</p>
<ol>
<li><strong>请求域（Request域）</strong>：请求域是一种用于在同一次 <em>HTTP</em> 请求处理周期内共享数据的域对象。数据存储在请求对象中，只在当前请求内有效。</li>
<li><strong>会话域（Session域）</strong>：会话域是一种用于在整个用户会话周期内共享数据的域对象。数据存储在会话对象中，可在用户登录后的多次请求之间共享。</li>
<li><strong>应用域（Application域）</strong>：应用域是一种用于在整个 <em>Web</em> 应用程序周期内共享数据的域对象。数据存储在 <code>ServletContext</code> 对象中，可被整个应用程序的所有 <code>Servlet</code> 共享。</li>
</ol>
<p>具体参考：</p>
<p><a href="https://cloud.tencent.com/developer/article/2352713">【Java 进阶篇】在Java Web应用中实现请求数据的共享：域对象详解</a></p>
<h3 id="Servlet"><a class="header-anchor" href="#Servlet">¶</a><code>Servlet</code></h3>
<h4 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h4>
<blockquote>
<p><code>Servlet</code>（Server Applet），全称 <code>Java Servlet</code>，未有中文译文。是用<a href="https://zh.wikipedia.org/wiki/Java">Java</a>编写的<a href="https://zh.wikipedia.org/wiki/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F">程序</a>。其主要功能在于交互式地浏览和修改数据，生成动态<a href="https://zh.wikipedia.org/wiki/Web">Web</a>内容。狭义的 <code>Servlet</code> 是指Java语言实现的一个<a href="https://zh.wikipedia.org/wiki/%E6%8E%A5%E5%8F%A3">接口</a>，广义的 <code>Servlet</code> 是指任何实现了这个 <code>Servlet</code> 接口的<a href="https://zh.wikipedia.org/wiki/%E7%B1%BB_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">类</a>，一般情况下，人们将 <code>Servlet</code> 理解为后者。</p>
</blockquote>
<blockquote>
<p><code>Servlet</code> 运行于支持Java的<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8">应用服务器</a>中。从实现上讲，<code>Servlet</code> 可以响应任何类型的请求，但绝大多数情况下 <code>Servlet</code>只用来扩展基于<a href="https://zh.wikipedia.org/wiki/HTTP">HTTP</a><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%AE%AE">协议</a>的<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8">Web服务器</a>。</p>
<blockquote>
<p>引用自： <a href="https://blog.csdn.net/qq_19782019/article/details/80292110">JavaWeb——Servlet（全网最详细教程包括Servlet源码分析）</a></p>
</blockquote>
</blockquote>
<h4 id="servlet-和-controller-的区别"><a class="header-anchor" href="#servlet-和-controller-的区别">¶</a><code>servlet</code> 和 <code>controller</code> 的区别</h4>
<blockquote>
<p><code>web</code>应用程序开发人员通常编写<code>servlet</code>来处理请求，但是，当要使用 <code>Servlet</code> 完成复杂的功能时，需要编写多个 <code>Servlet</code> 类，并且在 <code>web.xml</code> 进行注册，这对于完成复杂的 <code>Web</code> 应用，代码编写会变得很复杂，开发成本也会很高。所以 <code>Spring</code> 提供了强大的 <code>Web</code> 开发框架<code> Spring MVC：Spring MVC</code> 是 <code>Spring</code> 产品的一部分，<code>Spring MVC</code> 是一个模型-视图-控制器的 <code>Web</code> 框架，建立在前端控制器 <code>servlet（DispatcherServlet）</code>，它负责发送每个请求到合适的处理程序，使用视图来返回响应结果。</p>
<blockquote>
<p>引用自：<a href="https://blog.csdn.net/qq_43530796/article/details/127078562">【SpringBoot】controller与servlet区别_servlet和controller的区别</a></p>
</blockquote>
</blockquote>
<p><em>controller</em> 是 <em>spring</em> 中的一个普通的 <em>bean</em> , 通过将请求发送到前端控制器然后经过一系列流程到达合适的 <em>controller</em> 并执行 <em>controller</em> 中的代码，使用 <em>springmvc</em> 可以很轻松的完成处理请求的工作</p>
<p><em>springmvc</em> 可以参考：<a href="https://zero-li.fun/2024/04/16/SpringMVC/">SpringMVC | 渡世之舟 (zero-li.fun)</a></p>
<h3 id="上下文"><a class="header-anchor" href="#上下文">¶</a>上下文</h3>
<blockquote>
<p><strong>上下文代表了程序当下所运行的环境，联系你整个 <code>app(应用程序)</code> 的生命周期与资源调用，是程序可以访问到的所有资源的总和，资源可以是一个变量，也可以是一个对象的引用。</strong></p>
</blockquote>
<blockquote>
<p>文章上下文，整片文章的语义。应用上下文，应用的语义——运行时的环境</p>
</blockquote>
<p>由上可知，上下文就是整个文章语义环境，是应用程序当前所有能访问的资源的集合。</p>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/84753477">到底什么是应用上下文？</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/650629290">计算机编程中的上下文（Context）到底是什么？从理解到实践</a></p>
<h3 id="过滤器"><a class="header-anchor" href="#过滤器">¶</a>过滤器</h3>
<p>顾名思义，过滤一些不符合要求的请求。</p>
<p>使用过滤器需要实现 <code>Filter</code> 接口，该接口中有三个方法需要实现</p>
<ul>
<li><code>init</code>：
<ul>
<li>在容器创建当前过滤器的时候调用</li>
</ul>
</li>
<li><code>doFilter</code>：
<ul>
<li>过滤器的具体过滤规则</li>
</ul>
</li>
<li><code>destroy</code>：
<ul>
<li>在容器中销毁当前过滤器的时候调用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyFilter类实现了Filter接口，用于对HTTP请求进行过滤。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Log</span>4j2 注解用于配置日志记录器。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@WebFilter</span>(&quot;/*&quot;) 注解指定了此过滤器应用于所有请求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的初始化方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterConfig 过滤器配置对象，提供了配置信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException 如果初始化过程中出现异常，则抛出ServletException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化过滤器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的核心方法，用于处理请求和响应。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletRequest 客户端的请求对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servletResponse 用于向客户端发送响应的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filterChain 过滤器链，用于将请求传递给下一个过滤器或servlet。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果处理请求或响应时发生IO错误，则抛出IOException。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ServletException 如果处理请求时发生Servlet相关错误，则抛出ServletException。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;过滤器开始工作&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过过滤器链将请求传递给下一个过滤器或servlet(放行)</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        log.info(<span class="string">&quot;过滤器结束工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤器的销毁方法，用于执行过滤器的清理工作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁过滤器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	如果有多个过滤器，使用 <code>@WebFilter</code> 注解会根据类名的字符排序来决定执行顺序，此外，还需要在启动类加入<code>@ServletComponentScan</code> 注解</p>
<h3 id="拦截器"><a class="header-anchor" href="#拦截器">¶</a>拦截器</h3>
<h3 id="监听器"><a class="header-anchor" href="#监听器">¶</a>监听器</h3>
<ol>
<li><code>ServletContextListener（上下文监听器）</code>：用于监听 <code>Web</code> 应用程序的启动和关闭事件。当<code>ServletContext</code>对象创建或销毁时，可以执行相应的操作。</li>
<li><code>HttpSessionListener（会话监听器）</code>：监听会话的创建和销毁事件。这对于跟踪在线用户、管理用户会话状态非常有用。</li>
<li><code>ServletRequestListener（请求监听器）</code>：监听请求的创建和销毁事件。可以用于记录请求信息、初始化数据等。</li>
</ol>
<p>在 <code>Spring</code> 框架中，也有一些特定的事件监听器：</p>
<ol>
<li><code>ApplicationListener</code>：<code>Spring</code> 提供的通用事件监听器接口。您可以自定义事件，继承<code>ApplicationEvent</code>类，并实现<code>ApplicationListener</code>接口来处理这些事件。例如，您可以监听自定义事件，如用户登录、订单创建等，以执行相应的业务逻辑。</li>
<li><code>Spring Boot中的事件监听器</code>：<code>Spring Boot</code> 继承了 <code>Spring</code> 的事件监听机制。您可以使用<code>@EventListener</code>注解来定义事件监听方法，将其与特定事件关联。例如，监听应用启动事件、数据库连接池初始化等。</li>
</ol>
<p>参考文章：</p>
<p><a href="https://developer.aliyun.com/article/688320">spring 监听器 Listener-阿里云开发者社区 ( <code>aliyun.com</code> )</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/145927110">深入浅出 <code>Spring/SpringBoot</code> 事件监听机制 - 知乎 ( <code>zhihu.com</code> )</a></p>
<p><em>Controller</em>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span> <span class="comment">// 定义一个RESTful控制器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetStudentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">// 注入GetStudent服务</span></span><br><span class="line">    GetStudent getstudent; <span class="comment">// 用于获取学生信息的服务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理GET请求，获取学生信息。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JsonResult&lt;String&gt; 包含学生信息的JSON结果，其中数据类型为String。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/GetStudent&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;String&gt; <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用getStudent服务，将结果封装在JsonResult中返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;(getstudent.getStudent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>getStudent</em>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="comment">// 标示一个Spring框架的服务组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetStudent</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">// 注入ApplicationContext对象，用于访问Spring应用上下文</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span> <span class="comment">// 注入Student对象，该对象将被用于演示事件发布时的数据载体</span></span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取并设置学生信息，然后发布一个学生信息更新的事件。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回设置好的学生信息字符串。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置学生的基本信息</span></span><br><span class="line">        student.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        student.setAge(<span class="number">18</span>);</span><br><span class="line">        student.setStudentNumber(<span class="string">&quot;20240001&quot;</span>);</span><br><span class="line">        <span class="comment">// 发布一个自定义事件，通知其他监听器学生信息已更新</span></span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> <span class="title class_">TestEvent</span>(<span class="built_in">this</span>, student.toString()));</span><br><span class="line">        <span class="comment">// 返回学生信息</span></span><br><span class="line">        <span class="keyword">return</span> student.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Event:</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TestEvent 类扩展了 ApplicationEvent 用于表示一个测试事件。</span></span><br><span class="line"><span class="comment"> * 这个类主要用于事件驱动的架构中，用来传递与学生相关的事件信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String student; <span class="comment">// 学生信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，用于创建一个 TestEvent 实例。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source 事件的来源对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> student 发生事件的学生信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestEvent</span><span class="params">(Object source, String student)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source); <span class="comment">// 调用父类构造函数，设置事件来源</span></span><br><span class="line">        <span class="built_in">this</span>.student = student; <span class="comment">// 设置事件相关的学生信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>EventListener</em>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试事件监听器类，用于监听TestEvent事件。</span></span><br><span class="line"><span class="comment"> * 使用Log4j2进行日志记录，并组件化以便于Spring容器管理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;TestEvent&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当监听到TestEvent事件时，处理该事件。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event 发生的TestEvent事件，包含需要处理的学生信息。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(TestEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 从事件中获取学生信息，并记录到日志中</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">student</span> <span class="operator">=</span> event.getStudent();</span><br><span class="line">        log.info(<span class="string">&quot;信息：&#123;&#125;&quot;</span>, student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中使用了监听器监听了自定义事件。首先，请求到达控制器，控制器获取学生信息，在学生信息类中发布一个自定义事件，然后监听器会捕获此事件并执行你自定义的事件内容</p>
<hr>
<p><code>Servlet API</code> 中文Doc：<a href="https://www.cnblogs.com/haimishasha/p/5609261.html#autoid-3-4-0"> <code>Java Servlet API</code> 中文说明文档 - 海米傻傻 - 博客园 ( <code>cnblogs.com</code> )</a></p>
<p>官方 <code>Servlet API</code> Doc：<a href="https://docs.oracle.com/javaee/7/api/javax/servlet/ServletRequest.html"> <code>ServletRequest</code> (Java™ EE 7 Specification APIs) ( <code>oracle.com</code> )</a></p>
<h3 id="Cookie"><a class="header-anchor" href="#Cookie">¶</a><em>Cookie</em></h3>
<blockquote>
<p><em>Cookie</em>，有时也用其复数形式 <em>Cookies</em>。类型为“<strong>小型文本文件</strong>”，是某些网站为了辨别用户身份，进行 <a href="https://baike.baidu.com/item/Session/479100?fromModule=lemma_inlink"><em>Session</em></a> 跟踪而储存在用户本地终端上的数据（通常经过加密），由用户<a href="https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF/101081?fromModule=lemma_inlink">客户端</a>计算机暂时或永久保存的<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF/111163?fromModule=lemma_inlink">信息</a> 。</p>
<blockquote>
<p>引用自<a href="https://baike.baidu.com/item/cookie/1119#reference-%5B3%5D-5062332-wrap">百度百科</a></p>
</blockquote>
</blockquote>
<p>​	使用 <em>cookie</em> 就可以使浏览器保存一些用户信息，来达到某些特定目的，比如打开网站在一定时间内不需要重复登录，或者使我们登录时可以自动填充账号密码等。</p>
<p>​	一般情况下，<em>cookie</em> 是以键值对的形式表示的<code>(key=value)</code></p>
<h4 id="cookie-常用属性"><a class="header-anchor" href="#cookie-常用属性">¶</a><em>cookie</em> 常用属性</h4>
<p><img src="https://s21.ax1x.com/2024/04/13/pFjt5fe.png" alt="cookie1" loading="lazy"></p>
<ul>
<li>
<p><em>Path</em>：该属性定义了 <em>Web</em> 站点上可以访问此 <em>Cookie</em> 的目录</p>
</li>
<li>
<p><em>Expires</em>：该属性表示 <em>Cookie</em> 的过期时间，也就是有效值，此 <em>Cookie</em> 在这个值之前都有效</p>
</li>
</ul>
<p>其他属性请参考百度百科</p>
<h4 id="cookie-在浏览器请求中的表现形式"><a class="header-anchor" href="#cookie-在浏览器请求中的表现形式">¶</a><em>cookie</em> 在浏览器请求中的表现形式</h4>
<p>请求头：</p>
<p><img src="https://s21.ax1x.com/2024/04/13/pFjNt9e.png" alt="cookie2" loading="lazy"></p>
<blockquote>
<p>通过上面可以发现，<code>cookie</code> 是以 <code>key=value</code> 表示的。多个 <code>cookie</code> 用 <code>;</code> 号隔开</p>
</blockquote>
<p>响应头：</p>
<p><img src="https://s21.ax1x.com/2024/04/13/pFjN0Bt.png" alt="cookie3" loading="lazy"></p>
<blockquote>
<p><code>cookie</code> 在响应中的表现形式为 <code>Set-Cookie=value</code> 。多个 <code>cookie</code> 使用多个 <code>Set-Cookie</code> 表示</p>
</blockquote>
<h4 id="cookie-的生命周期"><a class="header-anchor" href="#cookie-的生命周期">¶</a><em>cookie</em> 的生命周期</h4>
<p>​	<code>cookie</code> 有 2 种存储方式，一种是会话性，一种是持久性。</p>
<ul>
<li>会话性：如果 <code>cookie</code> 为会话性，那么 <code>cookie</code> 仅会保存在客户端的内存中，当我们关闭客户端时 <code>cookie</code> 也就失效了</li>
<li>持久性：如果 <code>cookie</code> 为持久性，那么 <code>cookie</code> 会保存在用户的硬盘中，直至生存期结束或者用户主动将其销毁。</li>
</ul>
<p>​    <code>cookie</code> 我们是可以进行设置的，我们可以人为设置 <code>cookie</code> 的有效时间，什么时候创建，什么时候销毁。</p>
<h4 id="cookie-的常用方法"><a class="header-anchor" href="#cookie-的常用方法">¶</a>cookie 的常用方法</h4>
<table>
<tr>
        <th align="center" colspan="2">构造方法</th>
    </tr>
    <tr>
        <td align="center">Cookie(String name, String value)</td>
        <td align="center">使用指定的名称和值创建一个新的 Cookie。</td>
    </tr>
</table>
<table>
    <tr>
        <th align="center">修饰符与类型</th>
        <th align="center">方法与描述</th>
    </tr>
    <tr>
        <td align="center" rowspan="2">Object</td>
        <td align="center">clone()</td>
    </tr>
    <tr>
        <td align="center">覆盖标准 java.lang.Object.clone 方法返回此 Cookie 的副本。</td>
    </tr>
    <tr>
        <td align="center" rowspan="2">String</td>
        <td align="center">getComment()</td>
    </tr>
    <tr>
        <td align="center">获取此 Cookie 用途的注释。如果此 Cookie 没有注释，则返回 null。</td>
    </tr>
    <tr>
        <td align="center" rowspan="2">int</td>
        <td align="center">getMaxAge()</td>
    </tr>
    <tr>
        <td align="center">获取此 Cookie 的最大期限（以秒为单位）。默认情况下，此 Cookie 的最大期限是 -1，表示此 Cookie
            将会持续存在，直至浏览器关闭而消失。
        </td>
    </tr>
    <tr>
        <td align="center" rowspan="2">String</td>
        <td align="center">getName()</td>
    </tr>
    <tr>
        <td align="center">获取此 Cookie 的当前名称。</td>
    </tr>
    <tr>
        <td align="center" rowspan="2">String</td>
        <td align="center">getValue()</td>
    </tr>
    <tr>
        <td align="center">获取此 Cookie 的当前值。</td>
    </tr>
    <tr>
        <td align="center" rowspan="2">String</td>
        <td align="center">getPath()</td>
    </tr>
    <tr>
        <td align="center">获取此 Cookie 的当前路径。</td>
    </tr>
    <tr>
        <td align="center" rowspan="2">void</td>
        <td align="center">setComment(String purpose)</td>
    </tr>
    <tr>
        <td align="center">设置此 Cookie 的注释。注释用于说明 Cookie 的用途。</td>
    </tr>
    <tr>
        <td align="center" rowspan="2">void</td>
        <td align="center">setMaxAge(int expiry)</td>
    </tr>
    <tr>
        <td align="center">设置此 Cookie 的最大期限（以秒为单位）。正值表示此 Cookie 将在设置的 expiry 后过期。注意，该值为 Cookie 过期的最长期限，而不是 Cookie 当前年龄。
            负值表示 Cookie 将在浏览器关闭时过期。零值表示 Cookie 会立马删除。
        </td>
    </tr>
    <tr>
        <td align="center" rowspan="2">void</td>
        <td align="center">setPath(String uri)</td>
    </tr>
    <tr>
        <td align="center">设置此 Cookie 的当前路径。</td>
    </tr>
    <tr>
        <td align="center" rowspan="2">void</td>
        <td align="center">setValue(String newValue)</td>
    </tr>
    <tr>
        <td align="center">为此 Cookie 的分配一个新值。</td>
    </tr>
</table>
<blockquote>
<p>更多请参考：<a href="https://docs.oracle.com/javaee/7/api/index.html">Cookie（Java（TM） EE 7 规范 API） (<code>oracle.com</code>)</a></p>
</blockquote>
<p><em>Cookie</em> 类位于 <code>javax.servlet.http</code> 下</p>
<p><code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 对 <em>cookie</em> 进行操作的常用方法</p>
<ul>
<li><code>response.addCookie(Cookie cookie)</code>
<ul>
<li>将 <em>cookie</em> 给客户端进行保存</li>
</ul>
</li>
<li><code>request.getCookies()</code>
<ul>
<li>得到客户端传过来的所有 <em>cookie</em> 对象</li>
</ul>
</li>
</ul>
<h4 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h4>
<p>使用 <em>cookie</em> 自动填充用户名和密码，使用 <em>session</em> 实现一天内登录过后无需登录</p>
<p><em><strong>login.html</strong></em>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 登录表单，向http://localhost:8080/login发送POST请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">        账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * 获取指定名称的cookie值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * <span class="doctag">@param</span> name 需要获取的cookie的名称</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     * <span class="doctag">@return</span> 返回cookie的值，如果不存在则返回null</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">     */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getCookie</span>(<span class="params">name</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> arr, reg = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;(^| )&quot;</span> + name + <span class="string">&quot;=([^;]*)(;|$)&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (arr = <span class="variable language_">document</span>.<span class="property">cookie</span>.<span class="title function_">match</span>(reg)) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> (arr[<span class="number">2</span>]);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="literal">null</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 从cookie中获取用户名和密码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> username_cookie = <span class="title function_">getCookie</span>(<span class="string">&quot;username&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> password_cookie = <span class="title function_">getCookie</span>(<span class="string">&quot;password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取HTML中对应的用户名和密码输入框元素</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> username_eb = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> password_eb = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;password&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 如果cookie中存在用户名和密码，且输入框元素存在，则将cookie中的用户名和密码填入输入框</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> ((username_cookie != <span class="literal">null</span> &amp;&amp; password_cookie != <span class="literal">null</span>) &amp;&amp; (username_eb != <span class="literal">null</span> &amp;&amp; password_eb != <span class="literal">null</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">        username_eb.<span class="title function_">setAttribute</span>(<span class="string">&quot;value&quot;</span>, username_cookie);</span></span><br><span class="line"><span class="language-javascript">        password_eb.<span class="title function_">setAttribute</span>(<span class="string">&quot;value&quot;</span>, password_cookie);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><em><strong>LoginController</strong></em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录处理控制器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  HttpServletRequest对象，用于接收客户端请求数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HttpServletResponse对象，用于向客户端发送响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回登录成功后重定向到的URL或登录失败后重新回到登录页面的URL</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果发生I/O错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/login&quot;, method = &#123;RequestMethod.POST, RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">loginController</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">// 用于存储用户输入的登录信息</span></span><br><span class="line">        <span class="type">var</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(); <span class="comment">// 获取当前会话对象</span></span><br><span class="line">        Cookie cookieUserName;</span><br><span class="line">        Cookie cookiePassword;</span><br><span class="line">        <span class="comment">// 从请求中获取用户名和密码，并存入hashMap中</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;username&quot;</span>, request.getParameter(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">        hashMap.put(<span class="string">&quot;password&quot;</span>, request.getParameter(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">        <span class="comment">// 调用Login类的login方法进行登录验证</span></span><br><span class="line">        <span class="keyword">if</span> (Login.login(hashMap)) &#123;</span><br><span class="line">            <span class="comment">// 登录成功，创建并设置用户名和密码的Cookie</span></span><br><span class="line">            cookieUserName = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;username&quot;</span>, hashMap.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">            cookiePassword = <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;password&quot;</span>, hashMap.get(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">            cookieUserName.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>); <span class="comment">// 设置Cookie有效期为1天</span></span><br><span class="line">            cookiePassword.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">            <span class="comment">// 设置会话有效期为1天</span></span><br><span class="line">            session.setMaxInactiveInterval(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">            response.addCookie(cookieUserName);</span><br><span class="line">            response.addCookie(cookiePassword);</span><br><span class="line">            <span class="comment">// 在会话中设置用户名，以便在其他页面中使用</span></span><br><span class="line">            session.setAttribute(<span class="string">&quot;username&quot;</span>, hashMap.get(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">            <span class="comment">// 登录成功，重定向到首页</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 登录失败，重定向回登录页面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;redirect:/login.html&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>Index</strong></em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理访问首页的请求。</span></span><br><span class="line"><span class="comment">     * 如果用户已登录（即会话中包含用户名），则显示欢迎页面；</span></span><br><span class="line"><span class="comment">     * 否则，重定向到登录页面。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  HttpServletRequest对象，用于获取请求信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response HttpServletResponse对象，用于设置响应信息和发送响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果发生I/O错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/index*&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">var</span> <span class="variable">username</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;username&quot;</span>); <span class="comment">// 尝试从会话中获取用户名</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">if</span> (username != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已登录，设置响应为HTML格式，并输出欢迎页面</span></span><br><span class="line">            response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">            out.write(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">                    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;head&gt;</span></span><br><span class="line"><span class="string">                        &lt;meta charset=&quot;utf-8&quot;&gt;</span></span><br><span class="line"><span class="string">                        &lt;title&gt;Title&lt;/title&gt;</span></span><br><span class="line"><span class="string">                    &lt;/head&gt;</span></span><br><span class="line"><span class="string">                    &lt;body&gt;</span></span><br><span class="line"><span class="string">                    &lt;h1&gt;success&lt;/h1&gt;</span></span><br><span class="line"><span class="string">                    &lt;div&gt;</span></span><br><span class="line"><span class="string">                        &lt;p&gt;</span></span><br><span class="line"><span class="string">                            welcome\s&quot;&quot;&quot;</span> + username + <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                        &lt;/p&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;</span></span><br><span class="line"><span class="string">                    &lt;/body&gt;</span></span><br><span class="line"><span class="string">                    &lt;/html&gt;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 用户未登录，重定向到登录页面</span></span><br><span class="line">            response.sendRedirect(request.getContextPath() + <span class="string">&quot;/login.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动填充逻辑：</p>
<p>​	先访问 <code>index</code> 接口，它会判断有没有登录，没有登录的话会重定向到 <code>login.html</code> 界面。在 <code>login</code> 接口中验证用户名和密码，并将 <code>cookie</code> 放到响应头中返回给客户端存储，如果登录成功则重定向到 <code>index</code> 主页，否则重定向到 <code>login.html</code> 重新登录。</p>
<p>​	之后关闭浏览器，访问 <code>index</code> 接口，由于请求头会携带 <code>cookie</code> 以及 <code>session</code> ， 所以只要 <code>session</code> 没有过期就可以直接访问。</p>
<p>​	访问 <code>login.html</code> 则 <code>HTML</code> 中的 <code>JavaScript</code> 代码会获取 <code>cookie</code> ，以便实现自动填充。</p>
<h4 id="流程图"><a class="header-anchor" href="#流程图">¶</a>流程图</h4>
<p><img src="https://s21.ax1x.com/2024/04/13/pFjH4SO.png" alt="流程图" loading="lazy"></p>
<hr>
<p><em>TODO</em></p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Java</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>spring开发注解集合</title>
    <url>/2024/04/16/spring%E5%BC%80%E5%8F%91%E6%B3%A8%E8%A7%A3%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h3 id="Spring-IoC-的常用注解"><a class="header-anchor" href="#Spring-IoC-的常用注解">¶</a>Spring IoC 的常用注解</h3>
<ul>
<li>
<p><code>@Component(value=&quot;&quot;)</code></p>
<ul>
<li>
<blockquote>
<p>1）使用此注解的类会被交由 <code>spring</code> 容器管理</p>
<p>2）value值为spring创建该类对象的 id 值</p>
<p>3）该注解使用类的无参构造方法创建对象</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@Value(&quot;&quot;)</code></p>
<ul>
<li>
<blockquote>
<p>1）使用此注解进行基本类型的注入，在括号内的引号中键入属性值</p>
<p>2）可以给 <code>set</code> 方法进行此注释</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@Autowired</code></p>
<ul>
<li>
<blockquote>
<p>1）使用此注解进行引用类型的注入，即<code>bean</code>对象的注入</p>
<p>2）可以声明在字段(属性)或<code>setter</code>方法上</p>
<p>3）默认使用<code>byType</code>注入，通过此注解的对象需要在<code>IoC</code>容器中存在，否则需要加上<code>required=false</code>，表示忽略当前要注入的<code>bean</code>，如果有就直接注入，没有跳过，不会报错</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@ComponentScan</code></p>
<ul>
<li>
<blockquote>
<p>1）此注释使组件扫描器扫描本类此包下的 <code>bean</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@Configuration</code></p>
<ul>
<li>
<blockquote>
<p>1）使用此注解定义配置类</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@Bean</code></p>
<ul>
<li>
<blockquote>
<p>1）此注解是 <code>spring</code> 中用于方法级别的注解，主要用于在 <code>Java</code> 配置类中定义一个 <code>Bean</code> 。</p>
<p>2）此注解告诉 <code>spring</code> 这个方法将返回一个对象，该对象应该被注册为 <code>spring</code> 容器中的一个 <code>Bean</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-MVC-的常用注解"><a class="header-anchor" href="#Spring-MVC-的常用注解">¶</a>Spring MVC 的常用注解</h3>
<ul>
<li>
<p><code>@Controller</code></p>
<ul>
<li>
<blockquote>
<p>1）使用此注解的类，其中的方法如果没有被此注解修饰，一般都是返回一个视图（一个具体的页面），这个视图会和模板引擎结合在一起使用</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@RestController</code></p>
<ul>
<li>
<blockquote>
<p>1）此注解基本上等于 <code>@RequesBody</code>  + <code>@Controller</code></p>
<p>2）使用此注解会直接返回一个<code>JSON</code> 数据</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@RequestMapping</code></p>
<ul>
<li>
<blockquote>
<p>1）使用此注解来映射请求，也就是通过它来指定控制器可以处理那些 <code>URL</code> 请求</p>
<p>2）此注解除了 <code>name()</code> 方法，其他的方法都可以定义多个属性值，如 <code>value()</code> 和 <code>path()</code> 都可以同时定义多个字符串值来接收多个 <code>URL</code> 请求</p>
</blockquote>
<ul>
<li>
<p><code>path</code>：可以处理的 <code>url</code> 路径，<code>value</code> 效果和 <code>path</code> 相同</p>
</li>
<li>
<p><code>method</code>：此属性用来定义浏览器的请求方式，可以使用此属性指定方法仅处理哪些请求。有四种基本请求方式：1. <code>RequestMethod.GET</code>（查）2. <code>RequestMethod.POST</code>（增） 3. <code>RequestMethod.PUT</code>（改） 4. <code>RequestMethod.DELETE</code>（删）。常用的只有 1、2 两种</p>
</li>
<li>
<p><code>params</code>：可以使用此属性限制请求参数，只有带指定参数的请求才会被响应</p>
</li>
<li>
<p><code>headers</code>：此属性表示请求头，可以使用此属性限制客户端发来的请求</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>@PathVariable</code></p>
<ul>
<li>
<blockquote>
<p>1）可以通过此注解将 <code>URL</code> 中的占位符绑定到控制器的处理方法的参数中，占位符可以在任何位置，占位符使用<code>&#123;&#125;</code>括起来，如：<code>@RequestMapping(&quot;/books/&#123;id&#125;/&#123;authorName&#125;&quot;)</code></p>
<p>2）通过此注解可以将 <code>URL</code> 中的参数接收，URL 中的参数名需与方法接收参数名保持一致，否则无法接收。可以通过 <code>@PathVariable</code> 的 <code>value</code> 属性指定参数名</p>
<p>3）此注解是直接放在形参中的，如：<code>public String testBook(@PathVariable Integer id, @PathVariable(value=&quot;authorName&quot;) String name)&#123;&#125;</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><code>@RequestParam</code></p>
<ul>
<li>
<blockquote>
<p>1）通过此注解从 <code>request</code>（请求） 中获取数值。</p>
<p>2）与上一个注解的区别在于请求数据风格不同，如：<code>http://localhost:8080/user?id=1</code></p>
</blockquote>
<ul>
<li><code>value</code>：当传入的参数和方法参数名不一致时，可以使用 <code>value</code> 指定传入的参数名</li>
<li><code>required</code>：是布尔值，用来表示该参数是否为必须传入</li>
<li><code>defaultValue</code>：默认值，表示请求中没有同名的参数时的默认值</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>@RequestBody</code></p>
<ul>
<li>
<blockquote>
<p>1）将 <code>HTTP</code> 请求体数据自动绑定到指定类型的参数</p>
<p>2）支持多种数据格式（如 <code>JSON</code>、<code>XML</code>）与 <code>Java</code> 类型（如 <code>POJO</code>、<code>List</code>、<code>Map</code>）的映射，借助 <code>HttpMessageConverter</code> 实现</p>
<p>3）可与 <code>@RequestParam</code>、<code>@PathVariable</code> 等注解共存，以便在一个方法中处理多种来源的请求数据</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="其他注解"><a class="header-anchor" href="#其他注解">¶</a>其他注解</h3>
<p><code>@Resource</code></p>
<ul>
<li>
<blockquote>
<p>1）此注解为<code>J2EE</code>提供</p>
<p>2）跟<code>@Autowired</code>一样，都是为<code>bean</code>对象注入，同样可以声明到字段或<code>setter</code>方法上</p>
<p>3）默认使用<code>byName</code>注入，没有则通过<code>byType</code>方式注入</p>
<p>更多关于此注解的细节参考：<a href="https://blog.csdn.net/qq_45590494/article/details/114444371">@Autowired和@Resource注解的区别和联系</a></p>
</blockquote>
</li>
</ul>
<h3 id="注入方式"><a class="header-anchor" href="#注入方式">¶</a>注入方式</h3>
<ul>
<li><code>byName</code>
<ul>
<li>简单说就是使用变量名去 <code>IoC</code>  容器中匹配合适<code>bean</code>的<code>id</code>属性</li>
</ul>
</li>
<li><code>byType</code>
<ul>
<li>使用变量类型去匹配<code>bean</code>的<code>class</code>属性</li>
</ul>
</li>
</ul>
<p>具体可以参考：<a href="https://blog.csdn.net/tanga842428/article/details/54694484">Spring中的byName与byType_springboot byname和 bytype</a></p>
<h3 id="封装实体类接收表单数据"><a class="header-anchor" href="#封装实体类接收表单数据">¶</a>封装实体类接收表单数据</h3>
<p>在表单数据过多时，可以封装实体类接收参数</p>
<p><em>Demo</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(User user)</span>&#123;<span class="comment">//直接传入实体类的对象</span></span><br><span class="line">    System.out.println(user.getUsername);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><em>TODO</em></p>
]]></content>
      <categories>
        <category>spring系列</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>spring注解</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot基础</title>
    <url>/2024/04/16/SpringBoot%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="Springboot-简介"><a class="header-anchor" href="#Springboot-简介">¶</a><em>Springboot</em> 简介</h3>
<blockquote>
<blockquote>
<p>​	<em>Spring Boot</em>是由<em>Pivotal</em>团队提供的全新框架，其设计目的是用来简化新<em>Spring</em>应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，<em>Spring Boot</em>致力于在蓬勃发展的快速应用开发领域(<em>rapid application development</em>)成为领导者。</p>
</blockquote>
<p>引用自百度百科</p>
</blockquote>
<p>总结：使用 <em>springboot</em>可以很快的创建一个<em>springweb</em>项目，极大的简化<em>spring</em>的配置，让你专注于后端开发而不用关心繁琐的配置。</p>
<h3 id="Springboot-项目结构"><a class="header-anchor" href="#Springboot-项目结构">¶</a><em>Springboot</em> 项目结构</h3>
<ul>
<li><em>resources</em> 资源文件夹
<ul>
<li><em>static</em> 保存所有静态资源（<em>js、css、images</em>等）</li>
<li><em>templates</em> 保存所有模板页面</li>
<li><em>application.properties</em> 文件，用来编写一些服务器配置文件。但是更推荐使用 <em>yaml</em> 后缀来配置。</li>
</ul>
</li>
</ul>
<h3 id="JSR303-校验"><a class="header-anchor" href="#JSR303-校验">¶</a><em>JSR303</em> 校验</h3>
<p>使用 <em>JSR303</em> 校验可以很轻松的在后端完成数据校验工作，只需要在要校验的实体类上加入相应的注解即可。</p>
<table>
    <tr align="center">
        <th colspan="2"><b>空检查</b></th>
    </tr>
    <tr align="center">
        <td><b>注解</b></td>
        <td><b>说明</b></td>
    </tr>
    <tr align="center">
        <td>@Null</td>
        <td>验证对象是否为null</td>
    </tr>
    <tr align="center">
        <td>@NotNull</td>
        <td>验证对象是否不为null，无法检查长度为0的字符串</td>
    </tr>
    <tr align="center">
        <td>@NotBlank</td>
        <td>检查约束字符串是不是Null还有被Trim的长度是否大于0，只对字符串，且会去掉前后空格</td>
    </tr>
    <tr align="center">
        <td>@NotEmpty</td>
        <td>检查约束元素是否为Null或者是EMPTY</td>
    </tr>
</table>
<table>
    <tr align="center">
        <th colspan="2"><b>Booelan检查</b></th>
    </tr>
    <tr align="center">
        <td><b>注解</b></td>
        <td><b>说明</b></td>
    </tr>
    <tr align="center">
        <td>@AssertTrue</td>
        <td>验证Boolean对象是否为true</td>
    </tr>
    <tr align="center">
        <td>@AssertFalse</td>
        <td>验证Boolean对象是否为false</td>
    </tr>
</table>
<table>
    <tr align="center">
        <th colspan="2"><b>长度检查</b></th>
    </tr>
    <tr align="center">
        <td><b>注解</b></td>
        <td><b>说明</b></td>
    </tr>
    <tr align="center">
        <td>@Size(min=,max=)</td>
        <td>验证对象(Array,Collection,Map,String)大小是否在给定范围之内</td>
    </tr>
    <tr align="center">
        <td>@Length(min=,max=)</td>
        <td>验证对象的长度是否在给定范围内</td>
    </tr>
</table>
<table>
    <tr align="center">
        <th colspan="2"><b>日期检查</b></th>
    </tr>
    <tr align="center">
        <td><b>注解</b></td>
        <td><b>说明</b></td>
    </tr>
    <tr align="center">
        <td>@Past</td>
        <td>验证Date和Calendar对象是否在当前时间之前</td>
    </tr>
    <tr align="center">
        <td>@Future</td>
        <td>验证Date和Calendar对象是否在当前时间之后</td>
    </tr>
    <tr align="center">
        <td>@Pattern</td>
        <td>验证String对象是否符合正则表达式的规则</td>
    </tr>
</table>
<p>除了上面的注解标签，还可以自定义数据校验规则</p>
<hr>
<p><em>TODO</em></p>
]]></content>
      <categories>
        <category>spring系列</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2024/04/16/SpringMVC/</url>
    <content><![CDATA[<h3 id="Spring-MVC原理"><a class="header-anchor" href="#Spring-MVC原理">¶</a>Spring MVC原理</h3>
<h4 id="Spring-MVC工作原理图"><a class="header-anchor" href="#Spring-MVC工作原理图">¶</a><code>Spring MVC工作原理图</code></h4>
<p><img src="https://s21.ax1x.com/2024/04/17/pFxTxC6.png" alt="img" loading="lazy"></p>
<blockquote>
<p>在没有使用SpringMVC之前我们都是使用Servlet在做Web开发。但是使用Servlet开发在接收请求参数，数据共享，页面跳转等操作相对比较复杂。servlet是java进行web开发的标准，既然springMVC是对servlet的封装，那么很显然<strong>SpringMVC底层就是Servlet，SpringMVC就是对Servlet进行深层次的封装</strong></p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/100723581">SpringMVC【入门篇】 - 知乎 (zhihu.com)</a></p>
</blockquote>
</blockquote>
<h3 id="MVC模式"><a class="header-anchor" href="#MVC模式">¶</a>MVC模式</h3>
<p>MVC模式(<code>Model</code>-<code>View</code>-<code>Controller</code>)：解决页面代码和后台代码的分离</p>
<p>MVC分别是：模型<code>model(javabean)</code>、视图<code>view(jsp/img)</code>、控制器<code>Controller(Action/servlet)</code>。</p>
<p>注：此处的控制器是前端控制器<code>(DispatcherServlet)</code></p>
<p>C存在的目的就是为了保证M和V的一致性，当M发生改变时，C可以把M中的新内容更新到V中</p>
<hr>
<p><em>TODO</em></p>
]]></content>
      <categories>
        <category>spring系列</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring基础</title>
    <url>/2024/04/16/Spring%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="Spring、Spring-MVC、Spring-Boot、Spring-Cloud"><a class="header-anchor" href="#Spring、Spring-MVC、Spring-Boot、Spring-Cloud">¶</a>Spring、Spring MVC、Spring Boot、Spring Cloud</h3>
<blockquote>
<ol>
<li><strong>Spring</strong>：
<ul>
<li><code>Spring</code> 是一个轻量级的<strong>控制反转 (<code>IoC</code>)</strong> 和<strong>面向切面 (<code>AOP</code>)</strong> 的容器框架。</li>
<li>它使你能够编写更干净、更可管理、并且更易于测试的代码。</li>
<li><code>Spring</code> 提供了基础功能，适用于开发 <code>WEB</code> 层、业务层、持久层等多个方面。</li>
</ul>
</li>
<li><strong>Spring MVC</strong>：
<ul>
<li><code>Spring MVC</code> 是 <code>Spring</code> 的一个模块，是一个<strong>Web 框架</strong>。</li>
<li>通过 <code>Dispatcher Servlet</code>、<code>ModelAndView</code> 和 <code>View Resolver</code>，它使得开发 <code>Web</code> 应用变得很容易。</li>
<li>主要针对网站应用程序或者服务开发，处理 URL 路由、<code>Session</code>、模板引擎、静态 <code>Web</code> 资源等。</li>
</ul>
</li>
<li><strong>Spring Boot</strong>：
<ul>
<li><code>Spring Boot</code> 是为简化 <code>Spring</code> 配置的<strong>快速开发整合包</strong>。</li>
<li>它约定优于配置，简化了 <code>Spring</code> 的配置流程。</li>
<li>更专注于开发<strong>微服务后台接口</strong>，不涉及前端视图。</li>
</ul>
</li>
<li><strong>Spring Cloud</strong>：
<ul>
<li><code>Spring Cloud</code> 构建于 <code>Spring Boot</code> 之上，是一个关注全局的<strong>服务治理框架</strong>。</li>
<li>它用于整合和管理多个 <code>Spring Boot</code> 单体微服务。</li>
<li><code>Spring Cloud</code> 依赖于 <code>Spring Boot</code> 开发，但 <code>Spring Boot</code> 可以独立开发。</li>
</ul>
</li>
</ol>
<p>总结：</p>
<ul>
<li>Spring 是核心，提供了基础功能。</li>
<li>Spring MVC 是基于 Spring 的一个 MVC 框架。</li>
<li>Spring Boot 是为简化 Spring 配置的快速开发整合包。</li>
<li>Spring Cloud 是构建在 Spring Boot 之上的服务治理框架。</li>
</ul>
</blockquote>
<h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3>
<p><code>spring</code>是一个专注于 <code>Java EE</code> 开发的框架，它会使我们编写出来的 <code>Java</code> 程序 更快，更容易，更安全。</p>
<h3 id="Spring的分层架构设计模式"><a class="header-anchor" href="#Spring的分层架构设计模式">¶</a>Spring的分层架构设计模式</h3>
<ol>
<li>
<p><strong>表示层（Controller层）</strong>：</p>
<ul>
<li>表示层是Web应用的入口，负责接收HTTP请求并处理。</li>
<li>在Spring中，它提供了与Spring MVC和Struts2等框架的整合。</li>
<li>控制器层处理用户请求，协调业务逻辑层和持久层之间的交互。</li>
</ul>
</li>
<li>
<p><strong>服务层（Service层）</strong>：</p>
<ul>
<li>也称为业务逻辑层，负责处理业务逻辑，与项目需求紧密相关。</li>
<li>在Spring中，可以管理事务、记录日志等。</li>
<li>服务层通过调用持久层的方法来操作数据，对外提供接口。</li>
</ul>
</li>
<li>
<p><strong>持久层（DAO层）</strong>：</p>
<ul>
<li>也被称为数据访问层，负责将数据持久化到数据库中。</li>
<li>基本上，它主要用于数据库的增删改查操作。</li>
<li>DAO层是一个接口，具体的实现在Mapper.xml或者其他地方。</li>
</ul>
</li>
</ol>
<h3 id="声明组件扫描器"><a class="header-anchor" href="#声明组件扫描器">¶</a>声明组件扫描器</h3>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;你要扫描的包名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring-相关网站"><a class="header-anchor" href="#Spring-相关网站">¶</a><code>Spring</code> 相关网站</h3>
<ul>
<li><code>Spring MVC API</code>
<ul>
<li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/">Overview (Spring Framework 6.1.5 API)</a></li>
</ul>
</li>
<li><code>Spring Boot API</code>
<ul>
<li><a href="https://docs.spring.io/spring-boot/docs/current/api/">Overview (Spring Boot 3.2.4 API)</a></li>
</ul>
</li>
</ul>
<hr>
<p><em>TODO</em></p>
]]></content>
      <categories>
        <category>spring系列</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot多模块开发</title>
    <url>/2024/04/16/springboot%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3>
<p>为了解决项目越来越大的问题，使用了多模块开发来使层次更加清晰。</p>
<p>架构大致如下：</p>
<p><img src="https://s21.ax1x.com/2024/04/15/pFvWf3j.png" alt="springboot多模块开发1" loading="lazy"></p>
<h3 id="流程"><a class="header-anchor" href="#流程">¶</a>流程</h3>
<p>（1）新建 <code>springboot</code> 项目；<br>
（2）在新建后的 <code>springboot</code> 项目中新建多个 <code>module(模块)</code>；<br>
（3）修改 <code>pom</code> 文件以及删除多余的文件及文件夹；<br>
（4）将原项目的代码放进去；</p>
<h3 id="多模块开发的坑"><a class="header-anchor" href="#多模块开发的坑">¶</a>多模块开发的坑</h3>
<p>由于第一次使用多模块开发，并不熟练，所以踩了很多坑，这里记录一下</p>
<ol>
<li>访问后台接口报<code>404</code></li>
</ol>
<p>​	访问所有接口都报404，这是由于<code>spring</code>没有扫描到你写的<code>bean</code>所导致的，一般来说，<code>spring</code> 容器只会扫描启动类所在的包以及其下的子包中的所有类，但是开发不会将所有的模块都放在一个包下面，所以如果你<code>service</code>、<code>dao</code>等模块放在了启动类所在的包之外，那么<code>spring</code>就不会去扫描注册这些<code>bean</code></p>
<p>​	解决方法是在启动类的<code>@SpringBootApplication</code>注解上面加上<code>scanBasePackages=&#123;&quot;xxx.xxxxx.*&quot;&#125;</code></p>
<p>​	<code>xxx.xxxxx</code> 是你所共有的包，就比如说我所有的模块都是以 <code>com.example.xxx</code> 开始。</p>
<p>​	如：</p>
<p><img src="https://s21.ax1x.com/2024/04/15/pFvfnqP.png" alt="springboot多模块开发2" loading="lazy"></p>
<p>​	要查看 <code>spring</code> 有没有注册你的 <code>bean</code> 可以到服务的 <code>Actuator</code> 中查看</p>
<p><img src="https://s21.ax1x.com/2024/04/15/pFv5css.png" alt="springboot多模块开发3" loading="lazy"></p>
<ol start="2">
<li>
<p><code>springboot</code>多模块的<code>@Resource</code>、<code>@Autowired</code> 注入为<code>NULL</code></p>
<p>方法一：</p>
</li>
</ol>
<p>​	导致注入失败的原因是因为使用了 <code>new</code> 去使用这个方法，只需要将此类自动注入即可解决问题</p>
<p>报错的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetStudentController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/GetStudent&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;String&gt; <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">studentInformation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">getStudent</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;(studentInformation.getStudent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改之后的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetStudentController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    getStudent studentInformation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(path = &quot;/GetStudent&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;String&gt; <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;(studentInformation.getStudent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	方法二：</p>
<p>​	封装一个 <code>StaticMethodGetBean</code> 的类，此类实现了 <code>ApplicationContextAware</code> 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodGetBean</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="comment">// Spring应用上下文，用于访问应用上下文中的bean</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置应用上下文。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> applicationContext Spring应用上下文实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        StaticMethodGetBean.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过类类型获取应用上下文中的bean。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 要获取的bean的类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回bean的实例，如果不存在则返回null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; bean的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getBean</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取bean实例，如果不存在则返回null</span></span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(clazz) != <span class="literal">null</span> ? applicationContext.getBean(clazz) : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在要使用的地方直接调用 <code>getBean</code> 方法获取即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GetStudentController</span>&#123;</span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/GetStudent&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> JsonResult&lt;String&gt; <span class="title function_">getStudent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">studentInformation</span> <span class="operator">=</span> StaticMethodGetBean.getBean(getStudent.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>&lt;&gt;(studentInformation.getStudent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://blog.csdn.net/yangyifan0/article/details/130570051">SpringBoot 简单多模块构建_springboot创建多模块项目</a></p>
<hr>
<p><em>TODO</em></p>
]]></content>
      <categories>
        <category>spring系列</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
</search>
